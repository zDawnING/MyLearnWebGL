/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "./dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/fpviewer_index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/index.js!./src/style/common/commom.css":
/*!***************************************************************!*\
  !*** ./node_modules/css-loader!./src/style/common/commom.css ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../../node_modules/css-loader/lib/css-base.js */ \"./node_modules/css-loader/lib/css-base.js\")(false);\n// imports\n\n\n// module\nexports.push([module.i, \"body{\\n\\tmargin: 0;\\n\\tpadding: 0;\\n}\", \"\"]);\n\n// exports\n\n\n//# sourceURL=webpack:///./src/style/common/commom.css?./node_modules/css-loader");

/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/*!*************************************************!*\
  !*** ./node_modules/css-loader/lib/css-base.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function(useSourceMap) {\n\tvar list = [];\n\n\t// return the list of modules as css string\n\tlist.toString = function toString() {\n\t\treturn this.map(function (item) {\n\t\t\tvar content = cssWithMappingToString(item, useSourceMap);\n\t\t\tif(item[2]) {\n\t\t\t\treturn \"@media \" + item[2] + \"{\" + content + \"}\";\n\t\t\t} else {\n\t\t\t\treturn content;\n\t\t\t}\n\t\t}).join(\"\");\n\t};\n\n\t// import a list of modules into the list\n\tlist.i = function(modules, mediaQuery) {\n\t\tif(typeof modules === \"string\")\n\t\t\tmodules = [[null, modules, \"\"]];\n\t\tvar alreadyImportedModules = {};\n\t\tfor(var i = 0; i < this.length; i++) {\n\t\t\tvar id = this[i][0];\n\t\t\tif(typeof id === \"number\")\n\t\t\t\talreadyImportedModules[id] = true;\n\t\t}\n\t\tfor(i = 0; i < modules.length; i++) {\n\t\t\tvar item = modules[i];\n\t\t\t// skip already imported module\n\t\t\t// this implementation is not 100% perfect for weird media query combinations\n\t\t\t//  when a module is imported multiple times with different media queries.\n\t\t\t//  I hope this will never occur (Hey this way we have smaller bundles)\n\t\t\tif(typeof item[0] !== \"number\" || !alreadyImportedModules[item[0]]) {\n\t\t\t\tif(mediaQuery && !item[2]) {\n\t\t\t\t\titem[2] = mediaQuery;\n\t\t\t\t} else if(mediaQuery) {\n\t\t\t\t\titem[2] = \"(\" + item[2] + \") and (\" + mediaQuery + \")\";\n\t\t\t\t}\n\t\t\t\tlist.push(item);\n\t\t\t}\n\t\t}\n\t};\n\treturn list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n\tvar content = item[1] || '';\n\tvar cssMapping = item[3];\n\tif (!cssMapping) {\n\t\treturn content;\n\t}\n\n\tif (useSourceMap && typeof btoa === 'function') {\n\t\tvar sourceMapping = toComment(cssMapping);\n\t\tvar sourceURLs = cssMapping.sources.map(function (source) {\n\t\t\treturn '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'\n\t\t});\n\n\t\treturn [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n\t}\n\n\treturn [content].join('\\n');\n}\n\n// Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n\t// eslint-disable-next-line no-undef\n\tvar base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n\tvar data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n\n\treturn '/*# ' + data + ' */';\n}\n\n\n//# sourceURL=webpack:///./node_modules/css-loader/lib/css-base.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/*!****************************************************!*\
  !*** ./node_modules/style-loader/lib/addStyles.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = __webpack_require__(/*! ./urls */ \"./node_modules/style-loader/lib/urls.js\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/addStyles.js?");

/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/*!***********************************************!*\
  !*** ./node_modules/style-loader/lib/urls.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n\n\n//# sourceURL=webpack:///./node_modules/style-loader/lib/urls.js?");

/***/ }),

/***/ "./src/assets/img/sky.jpg":
/*!********************************!*\
  !*** ./src/assets/img/sky.jpg ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("module.exports = __webpack_require__.p + \"images/sky.2b11efd6.jpg\";\n\n//# sourceURL=webpack:///./src/assets/img/sky.jpg?");

/***/ }),

/***/ "./src/components/shader/fpviewer/TestShader.js":
/*!******************************************************!*\
  !*** ./src/components/shader/fpviewer/TestShader.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n/**\n * 测试shader\n * @type {Object}\n */\nvar TestShader = {\n\t// 顶点着色器\n\tvertexShader: [\"attribute vec4 a_Position;\", \"attribute vec2 a_TexCoord;\", \"uniform mat4 u_MVPMatrix;\", \"varying vec2 v_TexCoord;\", \"void main(){\", \"gl_Position = u_MVPMatrix * a_Position;\", \"v_TexCoord = a_TexCoord;\", \"}\"].join(\"\\n\"),\n\t// 片元着色器\n\tfragmentShader: [\"#ifdef GL_ES\", \"precision mediump float;\", \"#endif\", \"uniform sampler2D u_Sampler;\", \"varying vec2 v_TexCoord;\", \"void main(){\", \"gl_FragColor = texture2D(u_Sampler, v_TexCoord);\", \"}\"].join(\"\\n\")\n};\n\nexports.default = TestShader;\n\n//# sourceURL=webpack:///./src/components/shader/fpviewer/TestShader.js?");

/***/ }),

/***/ "./src/fpviewer_index.js":
/*!*******************************!*\
  !*** ./src/fpviewer_index.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _index = __webpack_require__(/*! fpviewer/index */ \"./src/views/fpviewer/index.js\");\n\nvar _index2 = _interopRequireDefault(_index);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n__webpack_require__(/*! ./style/common/commom.css */ \"./src/style/common/commom.css\");\n\nnew Promise(_index2.default).then(function (canvas) {\n\tdocument.getElementById(\"app\").appendChild(canvas);\n});\n\n//# sourceURL=webpack:///./src/fpviewer_index.js?");

/***/ }),

/***/ "./src/style/common/commom.css":
/*!*************************************!*\
  !*** ./src/style/common/commom.css ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("\nvar content = __webpack_require__(/*! !../../../node_modules/css-loader!./commom.css */ \"./node_modules/css-loader/index.js!./src/style/common/commom.css\");\n\nif(typeof content === 'string') content = [[module.i, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = __webpack_require__(/*! ../../../node_modules/style-loader/lib/addStyles.js */ \"./node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(false) {}\n\n//# sourceURL=webpack:///./src/style/common/commom.css?");

/***/ }),

/***/ "./src/vendor/webgl/cuon-matrix.js":
/*!*****************************************!*\
  !*** ./src/vendor/webgl/cuon-matrix.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n// cuon-matrix.js (c) 2012 kanda and matsuda\n/** \r\n * This is a class treating 4x4 matrix.\r\n * This class contains the function that is equivalent to OpenGL matrix stack.\r\n * The matrix after conversion is calculated by multiplying a conversion matrix from the right.\r\n * The matrix is replaced by the calculated result.\r\n */\n\n/**\r\n * Constructor of Matrix4\r\n * If opt_src is specified, new matrix is initialized by opt_src.\r\n * Otherwise, new matrix is initialized by identity matrix.\r\n * @param opt_src source matrix(option)\r\n */\nvar Matrix4 = exports.Matrix4 = function Matrix4(opt_src) {\n  var i, s, d;\n  if (opt_src && (typeof opt_src === 'undefined' ? 'undefined' : _typeof(opt_src)) === 'object' && opt_src.hasOwnProperty('elements')) {\n    s = opt_src.elements;\n    d = new Float32Array(16);\n    for (i = 0; i < 16; ++i) {\n      d[i] = s[i];\n    }\n    this.elements = d;\n  } else {\n    this.elements = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);\n  }\n};\n\n/**\r\n * Set the identity matrix.\r\n * @return this\r\n */\nMatrix4.prototype.setIdentity = function () {\n  var e = this.elements;\n  e[0] = 1;e[4] = 0;e[8] = 0;e[12] = 0;\n  e[1] = 0;e[5] = 1;e[9] = 0;e[13] = 0;\n  e[2] = 0;e[6] = 0;e[10] = 1;e[14] = 0;\n  e[3] = 0;e[7] = 0;e[11] = 0;e[15] = 1;\n  return this;\n};\n\n/**\r\n * Copy matrix.\r\n * @param src source matrix\r\n * @return this\r\n */\nMatrix4.prototype.set = function (src) {\n  var i, s, d;\n\n  s = src.elements;\n  d = this.elements;\n\n  if (s === d) {\n    return;\n  }\n\n  for (i = 0; i < 16; ++i) {\n    d[i] = s[i];\n  }\n\n  return this;\n};\n\n/**\r\n * Multiply the matrix from the right.\r\n * @param other The multiply matrix\r\n * @return this\r\n */\nMatrix4.prototype.concat = function (other) {\n  var i, e, a, b, ai0, ai1, ai2, ai3;\n\n  // Calculate e = a * b\n  e = this.elements;\n  a = this.elements;\n  b = other.elements;\n\n  // If e equals b, copy b to temporary matrix.\n  if (e === b) {\n    b = new Float32Array(16);\n    for (i = 0; i < 16; ++i) {\n      b[i] = e[i];\n    }\n  }\n\n  for (i = 0; i < 4; i++) {\n    ai0 = a[i];ai1 = a[i + 4];ai2 = a[i + 8];ai3 = a[i + 12];\n    e[i] = ai0 * b[0] + ai1 * b[1] + ai2 * b[2] + ai3 * b[3];\n    e[i + 4] = ai0 * b[4] + ai1 * b[5] + ai2 * b[6] + ai3 * b[7];\n    e[i + 8] = ai0 * b[8] + ai1 * b[9] + ai2 * b[10] + ai3 * b[11];\n    e[i + 12] = ai0 * b[12] + ai1 * b[13] + ai2 * b[14] + ai3 * b[15];\n  }\n\n  return this;\n};\nMatrix4.prototype.multiply = Matrix4.prototype.concat;\n\n/**\r\n * Multiply the three-dimensional vector.\r\n * @param pos  The multiply vector\r\n * @return The result of multiplication(Float32Array)\r\n */\nMatrix4.prototype.multiplyVector3 = function (pos) {\n  var e = this.elements;\n  var p = pos.elements;\n  var v = new Vector3();\n  var result = v.elements;\n\n  result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + e[12];\n  result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + e[13];\n  result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + e[14];\n\n  return v;\n};\n\n/**\r\n * Multiply the four-dimensional vector.\r\n * @param pos  The multiply vector\r\n * @return The result of multiplication(Float32Array)\r\n */\nMatrix4.prototype.multiplyVector4 = function (pos) {\n  var e = this.elements;\n  var p = pos.elements;\n  var v = new Vector4();\n  var result = v.elements;\n\n  result[0] = p[0] * e[0] + p[1] * e[4] + p[2] * e[8] + p[3] * e[12];\n  result[1] = p[0] * e[1] + p[1] * e[5] + p[2] * e[9] + p[3] * e[13];\n  result[2] = p[0] * e[2] + p[1] * e[6] + p[2] * e[10] + p[3] * e[14];\n  result[3] = p[0] * e[3] + p[1] * e[7] + p[2] * e[11] + p[3] * e[15];\n\n  return v;\n};\n\n/**\r\n * Transpose the matrix.\r\n * @return this\r\n */\nMatrix4.prototype.transpose = function () {\n  var e, t;\n\n  e = this.elements;\n\n  t = e[1];e[1] = e[4];e[4] = t;\n  t = e[2];e[2] = e[8];e[8] = t;\n  t = e[3];e[3] = e[12];e[12] = t;\n  t = e[6];e[6] = e[9];e[9] = t;\n  t = e[7];e[7] = e[13];e[13] = t;\n  t = e[11];e[11] = e[14];e[14] = t;\n\n  return this;\n};\n\n/**\r\n * Calculate the inverse matrix of specified matrix, and set to this.\r\n * @param other The source matrix\r\n * @return this\r\n */\nMatrix4.prototype.setInverseOf = function (other) {\n  var i, s, d, inv, det;\n\n  s = other.elements;\n  d = this.elements;\n  inv = new Float32Array(16);\n\n  inv[0] = s[5] * s[10] * s[15] - s[5] * s[11] * s[14] - s[9] * s[6] * s[15] + s[9] * s[7] * s[14] + s[13] * s[6] * s[11] - s[13] * s[7] * s[10];\n  inv[4] = -s[4] * s[10] * s[15] + s[4] * s[11] * s[14] + s[8] * s[6] * s[15] - s[8] * s[7] * s[14] - s[12] * s[6] * s[11] + s[12] * s[7] * s[10];\n  inv[8] = s[4] * s[9] * s[15] - s[4] * s[11] * s[13] - s[8] * s[5] * s[15] + s[8] * s[7] * s[13] + s[12] * s[5] * s[11] - s[12] * s[7] * s[9];\n  inv[12] = -s[4] * s[9] * s[14] + s[4] * s[10] * s[13] + s[8] * s[5] * s[14] - s[8] * s[6] * s[13] - s[12] * s[5] * s[10] + s[12] * s[6] * s[9];\n\n  inv[1] = -s[1] * s[10] * s[15] + s[1] * s[11] * s[14] + s[9] * s[2] * s[15] - s[9] * s[3] * s[14] - s[13] * s[2] * s[11] + s[13] * s[3] * s[10];\n  inv[5] = s[0] * s[10] * s[15] - s[0] * s[11] * s[14] - s[8] * s[2] * s[15] + s[8] * s[3] * s[14] + s[12] * s[2] * s[11] - s[12] * s[3] * s[10];\n  inv[9] = -s[0] * s[9] * s[15] + s[0] * s[11] * s[13] + s[8] * s[1] * s[15] - s[8] * s[3] * s[13] - s[12] * s[1] * s[11] + s[12] * s[3] * s[9];\n  inv[13] = s[0] * s[9] * s[14] - s[0] * s[10] * s[13] - s[8] * s[1] * s[14] + s[8] * s[2] * s[13] + s[12] * s[1] * s[10] - s[12] * s[2] * s[9];\n\n  inv[2] = s[1] * s[6] * s[15] - s[1] * s[7] * s[14] - s[5] * s[2] * s[15] + s[5] * s[3] * s[14] + s[13] * s[2] * s[7] - s[13] * s[3] * s[6];\n  inv[6] = -s[0] * s[6] * s[15] + s[0] * s[7] * s[14] + s[4] * s[2] * s[15] - s[4] * s[3] * s[14] - s[12] * s[2] * s[7] + s[12] * s[3] * s[6];\n  inv[10] = s[0] * s[5] * s[15] - s[0] * s[7] * s[13] - s[4] * s[1] * s[15] + s[4] * s[3] * s[13] + s[12] * s[1] * s[7] - s[12] * s[3] * s[5];\n  inv[14] = -s[0] * s[5] * s[14] + s[0] * s[6] * s[13] + s[4] * s[1] * s[14] - s[4] * s[2] * s[13] - s[12] * s[1] * s[6] + s[12] * s[2] * s[5];\n\n  inv[3] = -s[1] * s[6] * s[11] + s[1] * s[7] * s[10] + s[5] * s[2] * s[11] - s[5] * s[3] * s[10] - s[9] * s[2] * s[7] + s[9] * s[3] * s[6];\n  inv[7] = s[0] * s[6] * s[11] - s[0] * s[7] * s[10] - s[4] * s[2] * s[11] + s[4] * s[3] * s[10] + s[8] * s[2] * s[7] - s[8] * s[3] * s[6];\n  inv[11] = -s[0] * s[5] * s[11] + s[0] * s[7] * s[9] + s[4] * s[1] * s[11] - s[4] * s[3] * s[9] - s[8] * s[1] * s[7] + s[8] * s[3] * s[5];\n  inv[15] = s[0] * s[5] * s[10] - s[0] * s[6] * s[9] - s[4] * s[1] * s[10] + s[4] * s[2] * s[9] + s[8] * s[1] * s[6] - s[8] * s[2] * s[5];\n\n  det = s[0] * inv[0] + s[1] * inv[4] + s[2] * inv[8] + s[3] * inv[12];\n  if (det === 0) {\n    return this;\n  }\n\n  det = 1 / det;\n  for (i = 0; i < 16; i++) {\n    d[i] = inv[i] * det;\n  }\n\n  return this;\n};\n\n/**\r\n * Calculate the inverse matrix of this, and set to this.\r\n * @return this\r\n */\nMatrix4.prototype.invert = function () {\n  return this.setInverseOf(this);\n};\n\n/**\r\n * Set the orthographic projection matrix.\r\n * @param left The coordinate of the left of clipping plane.\r\n * @param right The coordinate of the right of clipping plane.\r\n * @param bottom The coordinate of the bottom of clipping plane.\r\n * @param top The coordinate of the top top clipping plane.\r\n * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\r\n * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\r\n * @return this\r\n */\nMatrix4.prototype.setOrtho = function (left, right, bottom, top, near, far) {\n  var e, rw, rh, rd;\n\n  if (left === right || bottom === top || near === far) {\n    throw 'null frustum';\n  }\n\n  rw = 1 / (right - left);\n  rh = 1 / (top - bottom);\n  rd = 1 / (far - near);\n\n  e = this.elements;\n\n  e[0] = 2 * rw;\n  e[1] = 0;\n  e[2] = 0;\n  e[3] = 0;\n\n  e[4] = 0;\n  e[5] = 2 * rh;\n  e[6] = 0;\n  e[7] = 0;\n\n  e[8] = 0;\n  e[9] = 0;\n  e[10] = -2 * rd;\n  e[11] = 0;\n\n  e[12] = -(right + left) * rw;\n  e[13] = -(top + bottom) * rh;\n  e[14] = -(far + near) * rd;\n  e[15] = 1;\n\n  return this;\n};\n\n/**\r\n * Multiply the orthographic projection matrix from the right.\r\n * @param left The coordinate of the left of clipping plane.\r\n * @param right The coordinate of the right of clipping plane.\r\n * @param bottom The coordinate of the bottom of clipping plane.\r\n * @param top The coordinate of the top top clipping plane.\r\n * @param near The distances to the nearer depth clipping plane. This value is minus if the plane is to be behind the viewer.\r\n * @param far The distances to the farther depth clipping plane. This value is minus if the plane is to be behind the viewer.\r\n * @return this\r\n */\nMatrix4.prototype.ortho = function (left, right, bottom, top, near, far) {\n  return this.concat(new Matrix4().setOrtho(left, right, bottom, top, near, far));\n};\n\n/**\r\n * Set the perspective projection matrix.\r\n * @param left The coordinate of the left of clipping plane.\r\n * @param right The coordinate of the right of clipping plane.\r\n * @param bottom The coordinate of the bottom of clipping plane.\r\n * @param top The coordinate of the top top clipping plane.\r\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\r\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\r\n * @return this\r\n */\nMatrix4.prototype.setFrustum = function (left, right, bottom, top, near, far) {\n  var e, rw, rh, rd;\n\n  if (left === right || top === bottom || near === far) {\n    throw 'null frustum';\n  }\n  if (near <= 0) {\n    throw 'near <= 0';\n  }\n  if (far <= 0) {\n    throw 'far <= 0';\n  }\n\n  rw = 1 / (right - left);\n  rh = 1 / (top - bottom);\n  rd = 1 / (far - near);\n\n  e = this.elements;\n\n  e[0] = 2 * near * rw;\n  e[1] = 0;\n  e[2] = 0;\n  e[3] = 0;\n\n  e[4] = 0;\n  e[5] = 2 * near * rh;\n  e[6] = 0;\n  e[7] = 0;\n\n  e[8] = (right + left) * rw;\n  e[9] = (top + bottom) * rh;\n  e[10] = -(far + near) * rd;\n  e[11] = -1;\n\n  e[12] = 0;\n  e[13] = 0;\n  e[14] = -2 * near * far * rd;\n  e[15] = 0;\n\n  return this;\n};\n\n/**\r\n * Multiply the perspective projection matrix from the right.\r\n * @param left The coordinate of the left of clipping plane.\r\n * @param right The coordinate of the right of clipping plane.\r\n * @param bottom The coordinate of the bottom of clipping plane.\r\n * @param top The coordinate of the top top clipping plane.\r\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\r\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\r\n * @return this\r\n */\nMatrix4.prototype.frustum = function (left, right, bottom, top, near, far) {\n  return this.concat(new Matrix4().setFrustum(left, right, bottom, top, near, far));\n};\n\n/**\r\n * Set the perspective projection matrix by fovy and aspect.\r\n * @param fovy The angle between the upper and lower sides of the frustum.\r\n * @param aspect The aspect ratio of the frustum. (width/height)\r\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\r\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\r\n * @return this\r\n */\nMatrix4.prototype.setPerspective = function (fovy, aspect, near, far) {\n  var e, rd, s, ct;\n\n  if (near === far || aspect === 0) {\n    throw 'null frustum';\n  }\n  if (near <= 0) {\n    throw 'near <= 0';\n  }\n  if (far <= 0) {\n    throw 'far <= 0';\n  }\n\n  fovy = Math.PI * fovy / 180 / 2;\n  s = Math.sin(fovy);\n  if (s === 0) {\n    throw 'null frustum';\n  }\n\n  rd = 1 / (far - near);\n  ct = Math.cos(fovy) / s;\n\n  e = this.elements;\n\n  e[0] = ct / aspect;\n  e[1] = 0;\n  e[2] = 0;\n  e[3] = 0;\n\n  e[4] = 0;\n  e[5] = ct;\n  e[6] = 0;\n  e[7] = 0;\n\n  e[8] = 0;\n  e[9] = 0;\n  e[10] = -(far + near) * rd;\n  e[11] = -1;\n\n  e[12] = 0;\n  e[13] = 0;\n  e[14] = -2 * near * far * rd;\n  e[15] = 0;\n\n  return this;\n};\n\n/**\r\n * Multiply the perspective projection matrix from the right.\r\n * @param fovy The angle between the upper and lower sides of the frustum.\r\n * @param aspect The aspect ratio of the frustum. (width/height)\r\n * @param near The distances to the nearer depth clipping plane. This value must be plus value.\r\n * @param far The distances to the farther depth clipping plane. This value must be plus value.\r\n * @return this\r\n */\nMatrix4.prototype.perspective = function (fovy, aspect, near, far) {\n  return this.concat(new Matrix4().setPerspective(fovy, aspect, near, far));\n};\n\n/**\r\n * Set the matrix for scaling.\r\n * @param x The scale factor along the X axis\r\n * @param y The scale factor along the Y axis\r\n * @param z The scale factor along the Z axis\r\n * @return this\r\n */\nMatrix4.prototype.setScale = function (x, y, z) {\n  var e = this.elements;\n  e[0] = x;e[4] = 0;e[8] = 0;e[12] = 0;\n  e[1] = 0;e[5] = y;e[9] = 0;e[13] = 0;\n  e[2] = 0;e[6] = 0;e[10] = z;e[14] = 0;\n  e[3] = 0;e[7] = 0;e[11] = 0;e[15] = 1;\n  return this;\n};\n\n/**\r\n * Multiply the matrix for scaling from the right.\r\n * @param x The scale factor along the X axis\r\n * @param y The scale factor along the Y axis\r\n * @param z The scale factor along the Z axis\r\n * @return this\r\n */\nMatrix4.prototype.scale = function (x, y, z) {\n  var e = this.elements;\n  e[0] *= x;e[4] *= y;e[8] *= z;\n  e[1] *= x;e[5] *= y;e[9] *= z;\n  e[2] *= x;e[6] *= y;e[10] *= z;\n  e[3] *= x;e[7] *= y;e[11] *= z;\n  return this;\n};\n\n/**\r\n * Set the matrix for translation.\r\n * @param x The X value of a translation.\r\n * @param y The Y value of a translation.\r\n * @param z The Z value of a translation.\r\n * @return this\r\n */\nMatrix4.prototype.setTranslate = function (x, y, z) {\n  var e = this.elements;\n  e[0] = 1;e[4] = 0;e[8] = 0;e[12] = x;\n  e[1] = 0;e[5] = 1;e[9] = 0;e[13] = y;\n  e[2] = 0;e[6] = 0;e[10] = 1;e[14] = z;\n  e[3] = 0;e[7] = 0;e[11] = 0;e[15] = 1;\n  return this;\n};\n\n/**\r\n * Multiply the matrix for translation from the right.\r\n * @param x The X value of a translation.\r\n * @param y The Y value of a translation.\r\n * @param z The Z value of a translation.\r\n * @return this\r\n */\nMatrix4.prototype.translate = function (x, y, z) {\n  var e = this.elements;\n  e[12] += e[0] * x + e[4] * y + e[8] * z;\n  e[13] += e[1] * x + e[5] * y + e[9] * z;\n  e[14] += e[2] * x + e[6] * y + e[10] * z;\n  e[15] += e[3] * x + e[7] * y + e[11] * z;\n  return this;\n};\n\n/**\r\n * Set the matrix for rotation.\r\n * The vector of rotation axis may not be normalized.\r\n * @param angle The angle of rotation (degrees)\r\n * @param x The X coordinate of vector of rotation axis.\r\n * @param y The Y coordinate of vector of rotation axis.\r\n * @param z The Z coordinate of vector of rotation axis.\r\n * @return this\r\n */\nMatrix4.prototype.setRotate = function (angle, x, y, z) {\n  var e, s, c, len, rlen, nc, xy, yz, zx, xs, ys, zs;\n\n  angle = Math.PI * angle / 180;\n  e = this.elements;\n\n  s = Math.sin(angle);\n  c = Math.cos(angle);\n\n  if (0 !== x && 0 === y && 0 === z) {\n    // Rotation around X axis\n    if (x < 0) {\n      s = -s;\n    }\n    e[0] = 1;e[4] = 0;e[8] = 0;e[12] = 0;\n    e[1] = 0;e[5] = c;e[9] = -s;e[13] = 0;\n    e[2] = 0;e[6] = s;e[10] = c;e[14] = 0;\n    e[3] = 0;e[7] = 0;e[11] = 0;e[15] = 1;\n  } else if (0 === x && 0 !== y && 0 === z) {\n    // Rotation around Y axis\n    if (y < 0) {\n      s = -s;\n    }\n    e[0] = c;e[4] = 0;e[8] = s;e[12] = 0;\n    e[1] = 0;e[5] = 1;e[9] = 0;e[13] = 0;\n    e[2] = -s;e[6] = 0;e[10] = c;e[14] = 0;\n    e[3] = 0;e[7] = 0;e[11] = 0;e[15] = 1;\n  } else if (0 === x && 0 === y && 0 !== z) {\n    // Rotation around Z axis\n    if (z < 0) {\n      s = -s;\n    }\n    e[0] = c;e[4] = -s;e[8] = 0;e[12] = 0;\n    e[1] = s;e[5] = c;e[9] = 0;e[13] = 0;\n    e[2] = 0;e[6] = 0;e[10] = 1;e[14] = 0;\n    e[3] = 0;e[7] = 0;e[11] = 0;e[15] = 1;\n  } else {\n    // Rotation around another axis\n    len = Math.sqrt(x * x + y * y + z * z);\n    if (len !== 1) {\n      rlen = 1 / len;\n      x *= rlen;\n      y *= rlen;\n      z *= rlen;\n    }\n    nc = 1 - c;\n    xy = x * y;\n    yz = y * z;\n    zx = z * x;\n    xs = x * s;\n    ys = y * s;\n    zs = z * s;\n\n    e[0] = x * x * nc + c;\n    e[1] = xy * nc + zs;\n    e[2] = zx * nc - ys;\n    e[3] = 0;\n\n    e[4] = xy * nc - zs;\n    e[5] = y * y * nc + c;\n    e[6] = yz * nc + xs;\n    e[7] = 0;\n\n    e[8] = zx * nc + ys;\n    e[9] = yz * nc - xs;\n    e[10] = z * z * nc + c;\n    e[11] = 0;\n\n    e[12] = 0;\n    e[13] = 0;\n    e[14] = 0;\n    e[15] = 1;\n  }\n\n  return this;\n};\n\n/**\r\n * Multiply the matrix for rotation from the right.\r\n * The vector of rotation axis may not be normalized.\r\n * @param angle The angle of rotation (degrees)\r\n * @param x The X coordinate of vector of rotation axis.\r\n * @param y The Y coordinate of vector of rotation axis.\r\n * @param z The Z coordinate of vector of rotation axis.\r\n * @return this\r\n */\nMatrix4.prototype.rotate = function (angle, x, y, z) {\n  return this.concat(new Matrix4().setRotate(angle, x, y, z));\n};\n\n/**\r\n * Set the viewing matrix.\r\n * @param eyeX, eyeY, eyeZ The position of the eye point.\r\n * @param centerX, centerY, centerZ The position of the reference point.\r\n * @param upX, upY, upZ The direction of the up vector.\r\n * @return this\r\n */\nMatrix4.prototype.setLookAt = function (eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\n  var e, fx, fy, fz, rlf, sx, sy, sz, rls, ux, uy, uz;\n\n  fx = centerX - eyeX;\n  fy = centerY - eyeY;\n  fz = centerZ - eyeZ;\n\n  // Normalize f.\n  rlf = 1 / Math.sqrt(fx * fx + fy * fy + fz * fz);\n  fx *= rlf;\n  fy *= rlf;\n  fz *= rlf;\n\n  // Calculate cross product of f and up.\n  sx = fy * upZ - fz * upY;\n  sy = fz * upX - fx * upZ;\n  sz = fx * upY - fy * upX;\n\n  // Normalize s.\n  rls = 1 / Math.sqrt(sx * sx + sy * sy + sz * sz);\n  sx *= rls;\n  sy *= rls;\n  sz *= rls;\n\n  // Calculate cross product of s and f.\n  ux = sy * fz - sz * fy;\n  uy = sz * fx - sx * fz;\n  uz = sx * fy - sy * fx;\n\n  // Set to this.\n  e = this.elements;\n  e[0] = sx;\n  e[1] = ux;\n  e[2] = -fx;\n  e[3] = 0;\n\n  e[4] = sy;\n  e[5] = uy;\n  e[6] = -fy;\n  e[7] = 0;\n\n  e[8] = sz;\n  e[9] = uz;\n  e[10] = -fz;\n  e[11] = 0;\n\n  e[12] = 0;\n  e[13] = 0;\n  e[14] = 0;\n  e[15] = 1;\n\n  // Translate.\n  return this.translate(-eyeX, -eyeY, -eyeZ);\n};\n\n/**\r\n * Multiply the viewing matrix from the right.\r\n * @param eyeX, eyeY, eyeZ The position of the eye point.\r\n * @param centerX, centerY, centerZ The position of the reference point.\r\n * @param upX, upY, upZ The direction of the up vector.\r\n * @return this\r\n */\nMatrix4.prototype.lookAt = function (eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ) {\n  return this.concat(new Matrix4().setLookAt(eyeX, eyeY, eyeZ, centerX, centerY, centerZ, upX, upY, upZ));\n};\n\n/**\r\n * Multiply the matrix for project vertex to plane from the right.\r\n * @param plane The array[A, B, C, D] of the equation of plane \"Ax + By + Cz + D = 0\".\r\n * @param light The array which stored coordinates of the light. if light[3]=0, treated as parallel light.\r\n * @return this\r\n */\nMatrix4.prototype.dropShadow = function (plane, light) {\n  var mat = new Matrix4();\n  var e = mat.elements;\n\n  var dot = plane[0] * light[0] + plane[1] * light[1] + plane[2] * light[2] + plane[3] * light[3];\n\n  e[0] = dot - light[0] * plane[0];\n  e[1] = -light[1] * plane[0];\n  e[2] = -light[2] * plane[0];\n  e[3] = -light[3] * plane[0];\n\n  e[4] = -light[0] * plane[1];\n  e[5] = dot - light[1] * plane[1];\n  e[6] = -light[2] * plane[1];\n  e[7] = -light[3] * plane[1];\n\n  e[8] = -light[0] * plane[2];\n  e[9] = -light[1] * plane[2];\n  e[10] = dot - light[2] * plane[2];\n  e[11] = -light[3] * plane[2];\n\n  e[12] = -light[0] * plane[3];\n  e[13] = -light[1] * plane[3];\n  e[14] = -light[2] * plane[3];\n  e[15] = dot - light[3] * plane[3];\n\n  return this.concat(mat);\n};\n\n/**\r\n * Multiply the matrix for project vertex to plane from the right.(Projected by parallel light.)\r\n * @param normX, normY, normZ The normal vector of the plane.(Not necessary to be normalized.)\r\n * @param planeX, planeY, planeZ The coordinate of arbitrary points on a plane.\r\n * @param lightX, lightY, lightZ The vector of the direction of light.(Not necessary to be normalized.)\r\n * @return this\r\n */\nMatrix4.prototype.dropShadowDirectionally = function (normX, normY, normZ, planeX, planeY, planeZ, lightX, lightY, lightZ) {\n  var a = planeX * normX + planeY * normY + planeZ * normZ;\n  return this.dropShadow([normX, normY, normZ, -a], [lightX, lightY, lightZ, 0]);\n};\n\n/**\r\n * Constructor of Vector3\r\n * If opt_src is specified, new vector is initialized by opt_src.\r\n * @param opt_src source vector(option)\r\n */\nvar Vector3 = exports.Vector3 = function Vector3(opt_src) {\n  var v = new Float32Array(3);\n  if (opt_src && (typeof opt_src === 'undefined' ? 'undefined' : _typeof(opt_src)) === 'object') {\n    v[0] = opt_src[0];v[1] = opt_src[1];v[2] = opt_src[2];\n  }\n  this.elements = v;\n};\n\n/**\r\n  * Normalize.\r\n  * @return this\r\n  */\nVector3.prototype.normalize = function () {\n  var v = this.elements;\n  var c = v[0],\n      d = v[1],\n      e = v[2],\n      g = Math.sqrt(c * c + d * d + e * e);\n  if (g) {\n    if (g == 1) return this;\n  } else {\n    v[0] = 0;v[1] = 0;v[2] = 0;\n    return this;\n  }\n  g = 1 / g;\n  v[0] = c * g;v[1] = d * g;v[2] = e * g;\n  return this;\n};\n\n/**\r\n * Constructor of Vector4\r\n * If opt_src is specified, new vector is initialized by opt_src.\r\n * @param opt_src source vector(option)\r\n */\nvar Vector4 = exports.Vector4 = function Vector4(opt_src) {\n  var v = new Float32Array(4);\n  if (opt_src && (typeof opt_src === 'undefined' ? 'undefined' : _typeof(opt_src)) === 'object') {\n    v[0] = opt_src[0];v[1] = opt_src[1];v[2] = opt_src[2];v[3] = opt_src[3];\n  }\n  this.elements = v;\n};\n\n//# sourceURL=webpack:///./src/vendor/webgl/cuon-matrix.js?");

/***/ }),

/***/ "./src/vendor/webgl/cuon-utils.js":
/*!****************************************!*\
  !*** ./src/vendor/webgl/cuon-utils.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.initShaders = initShaders;\nexports.createProgram = createProgram;\nexports.loadShader = loadShader;\nexports.getWebGLContext = getWebGLContext;\n\nvar _webglUtils = __webpack_require__(/*! vendor_gl/webgl-utils */ \"./src/vendor/webgl/webgl-utils.js\");\n\nvar _webglUtils2 = _interopRequireDefault(_webglUtils);\n\nvar _webglDebug = __webpack_require__(/*! vendor_gl/webgl-debug */ \"./src/vendor/webgl/webgl-debug.js\");\n\nvar _webglDebug2 = _interopRequireDefault(_webglDebug);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// cuon-utils.js (c) 2012 kanda and matsuda\n/**\r\n * Create a program object and make current\r\n * @param gl GL context\r\n * @param vshader a vertex shader program (string)\r\n * @param fshader a fragment shader program (string)\r\n * @return true, if the program object was created and successfully made current \r\n */\nfunction initShaders(gl, vshader, fshader) {\n  var program = createProgram(gl, vshader, fshader);\n  if (!program) {\n    console.log('Failed to create program');\n    return false;\n  }\n\n  gl.useProgram(program);\n  gl.program = program;\n\n  return true;\n}\n\n/**\r\n * Create the linked program object\r\n * @param gl GL context\r\n * @param vshader a vertex shader program (string)\r\n * @param fshader a fragment shader program (string)\r\n * @return created program object, or null if the creation has failed\r\n */\nfunction createProgram(gl, vshader, fshader) {\n  // Create shader object\n  var vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);\n  var fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);\n  if (!vertexShader || !fragmentShader) {\n    return null;\n  }\n\n  // Create a program object\n  var program = gl.createProgram();\n  if (!program) {\n    return null;\n  }\n\n  // Attach the shader objects\n  gl.attachShader(program, vertexShader);\n  gl.attachShader(program, fragmentShader);\n\n  // Link the program object\n  gl.linkProgram(program);\n\n  // Check the result of linking\n  var linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n  if (!linked) {\n    var error = gl.getProgramInfoLog(program);\n    console.log('Failed to link program: ' + error);\n    gl.deleteProgram(program);\n    gl.deleteShader(fragmentShader);\n    gl.deleteShader(vertexShader);\n    return null;\n  }\n  return program;\n}\n\n/**\r\n * Create a shader object\r\n * @param gl GL context\r\n * @param type the type of the shader object to be created\r\n * @param source shader program (string)\r\n * @return created shader object, or null if the creation has failed.\r\n */\nfunction loadShader(gl, type, source) {\n  // Create shader object\n  var shader = gl.createShader(type);\n  if (shader == null) {\n    console.log('unable to create shader');\n    return null;\n  }\n\n  // Set the shader program\n  gl.shaderSource(shader, source);\n\n  // Compile the shader\n  gl.compileShader(shader);\n\n  // Check the result of compilation\n  var compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n  if (!compiled) {\n    var error = gl.getShaderInfoLog(shader);\n    console.log('Failed to compile shader: ' + error);\n    gl.deleteShader(shader);\n    return null;\n  }\n\n  return shader;\n}\n\n/** \r\n * Initialize and get the rendering for WebGL\r\n * @param canvas <cavnas> element\r\n * @param opt_debug flag to initialize the context for debugging\r\n * @return the rendering context for WebGL\r\n */\nfunction getWebGLContext(canvas, opt_debug) {\n  // Get the rendering context for WebGL\n  var gl = _webglUtils2.default.setupWebGL(canvas);\n  if (!gl) return null;\n\n  // if opt_debug is explicitly false, create the context for debugging\n  if (arguments.length < 2 || opt_debug) {\n    gl = _webglDebug2.default.makeDebugContext(gl);\n  }\n\n  return gl;\n}\n\n//# sourceURL=webpack:///./src/vendor/webgl/cuon-utils.js?");

/***/ }),

/***/ "./src/vendor/webgl/webgl-debug.js":
/*!*****************************************!*\
  !*** ./src/vendor/webgl/webgl-debug.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n//Copyright (c) 2009 The Chromium Authors. All rights reserved.\n//Use of this source code is governed by a BSD-style license that can be\n//found in the LICENSE file.\n\n// Various functions for helping debug WebGL apps.\n\nvar WebGLDebugUtils = function WebGLDebugUtils() {\n\n  /**\r\n   * Wrapped logging function.\r\n   * @param {string} msg Message to log.\r\n   */\n  var log = function log(msg) {\n    if (window.console && window.console.log) {\n      window.console.log(msg);\n    }\n  };\n\n  /**\r\n   * Which arguements are enums.\r\n   * @type {!Object.<number, string>}\r\n   */\n  var glValidEnumContexts = {\n\n    // Generic setters and getters\n\n    'enable': { 0: true },\n    'disable': { 0: true },\n    'getParameter': { 0: true },\n\n    // Rendering\n\n    'drawArrays': { 0: true },\n    'drawElements': { 0: true, 2: true },\n\n    // Shaders\n\n    'createShader': { 0: true },\n    'getShaderParameter': { 1: true },\n    'getProgramParameter': { 1: true },\n\n    // Vertex attributes\n\n    'getVertexAttrib': { 1: true },\n    'vertexAttribPointer': { 2: true },\n\n    // Textures\n\n    'bindTexture': { 0: true },\n    'activeTexture': { 0: true },\n    'getTexParameter': { 0: true, 1: true },\n    'texParameterf': { 0: true, 1: true },\n    'texParameteri': { 0: true, 1: true, 2: true },\n    'texImage2D': { 0: true, 2: true, 6: true, 7: true },\n    'texSubImage2D': { 0: true, 6: true, 7: true },\n    'copyTexImage2D': { 0: true, 2: true },\n    'copyTexSubImage2D': { 0: true },\n    'generateMipmap': { 0: true },\n\n    // Buffer objects\n\n    'bindBuffer': { 0: true },\n    'bufferData': { 0: true, 2: true },\n    'bufferSubData': { 0: true },\n    'getBufferParameter': { 0: true, 1: true },\n\n    // Renderbuffers and framebuffers\n\n    'pixelStorei': { 0: true, 1: true },\n    'readPixels': { 4: true, 5: true },\n    'bindRenderbuffer': { 0: true },\n    'bindFramebuffer': { 0: true },\n    'checkFramebufferStatus': { 0: true },\n    'framebufferRenderbuffer': { 0: true, 1: true, 2: true },\n    'framebufferTexture2D': { 0: true, 1: true, 2: true },\n    'getFramebufferAttachmentParameter': { 0: true, 1: true, 2: true },\n    'getRenderbufferParameter': { 0: true, 1: true },\n    'renderbufferStorage': { 0: true, 1: true },\n\n    // Frame buffer operations (clear, blend, depth test, stencil)\n\n    'clear': { 0: true },\n    'depthFunc': { 0: true },\n    'blendFunc': { 0: true, 1: true },\n    'blendFuncSeparate': { 0: true, 1: true, 2: true, 3: true },\n    'blendEquation': { 0: true },\n    'blendEquationSeparate': { 0: true, 1: true },\n    'stencilFunc': { 0: true },\n    'stencilFuncSeparate': { 0: true, 1: true },\n    'stencilMaskSeparate': { 0: true },\n    'stencilOp': { 0: true, 1: true, 2: true },\n    'stencilOpSeparate': { 0: true, 1: true, 2: true, 3: true },\n\n    // Culling\n\n    'cullFace': { 0: true },\n    'frontFace': { 0: true }\n  };\n\n  /**\r\n   * Map of numbers to names.\r\n   * @type {Object}\r\n   */\n  var glEnums = null;\n\n  /**\r\n   * Initializes this module. Safe to call more than once.\r\n   * @param {!WebGLRenderingContext} ctx A WebGL context. If\r\n   *    you have more than one context it doesn't matter which one\r\n   *    you pass in, it is only used to pull out constants.\r\n   */\n  function init(ctx) {\n    if (glEnums == null) {\n      glEnums = {};\n      for (var propertyName in ctx) {\n        if (typeof ctx[propertyName] == 'number') {\n          glEnums[ctx[propertyName]] = propertyName;\n        }\n      }\n    }\n  }\n\n  /**\r\n   * Checks the utils have been initialized.\r\n   */\n  function checkInit() {\n    if (glEnums == null) {\n      throw 'WebGLDebugUtils.init(ctx) not called';\n    }\n  }\n\n  /**\r\n   * Returns true or false if value matches any WebGL enum\r\n   * @param {*} value Value to check if it might be an enum.\r\n   * @return {boolean} True if value matches one of the WebGL defined enums\r\n   */\n  function mightBeEnum(value) {\n    checkInit();\n    return glEnums[value] !== undefined;\n  }\n\n  /**\r\n   * Gets an string version of an WebGL enum.\r\n   *\r\n   * Example:\r\n   *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\r\n   *\r\n   * @param {number} value Value to return an enum for\r\n   * @return {string} The string version of the enum.\r\n   */\n  function glEnumToString(value) {\n    checkInit();\n    var name = glEnums[value];\n    return name !== undefined ? name : \"*UNKNOWN WebGL ENUM (0x\" + value.toString(16) + \")\";\n  }\n\n  /**\r\n   * Returns the string version of a WebGL argument.\r\n   * Attempts to convert enum arguments to strings.\r\n   * @param {string} functionName the name of the WebGL function.\r\n   * @param {number} argumentIndx the index of the argument.\r\n   * @param {*} value The value of the argument.\r\n   * @return {string} The value as a string.\r\n   */\n  function glFunctionArgToString(functionName, argumentIndex, value) {\n    var funcInfo = glValidEnumContexts[functionName];\n    if (funcInfo !== undefined) {\n      if (funcInfo[argumentIndex]) {\n        return glEnumToString(value);\n      }\n    }\n    return value.toString();\n  }\n\n  /**\r\n   * Given a WebGL context returns a wrapped context that calls\r\n   * gl.getError after every command and calls a function if the\r\n   * result is not gl.NO_ERROR.\r\n   *\r\n   * @param {!WebGLRenderingContext} ctx The webgl context to\r\n   *        wrap.\r\n   * @param {!function(err, funcName, args): void} opt_onErrorFunc\r\n   *        The function to call when gl.getError returns an\r\n   *        error. If not specified the default function calls\r\n   *        console.log with a message.\r\n   */\n  function makeDebugContext(ctx, opt_onErrorFunc) {\n    init(ctx);\n    opt_onErrorFunc = opt_onErrorFunc || function (err, functionName, args) {\n      // apparently we can't do args.join(\",\");\n      var argStr = \"\";\n      for (var ii = 0; ii < args.length; ++ii) {\n        argStr += (ii == 0 ? '' : ', ') + glFunctionArgToString(functionName, ii, args[ii]);\n      }\n      log(\"WebGL error \" + glEnumToString(err) + \" in \" + functionName + \"(\" + argStr + \")\");\n    };\n\n    // Holds booleans for each GL error so after we get the error ourselves\n    // we can still return it to the client app.\n    var glErrorShadow = {};\n\n    // Makes a function that calls a WebGL function and then calls getError.\n    function makeErrorWrapper(ctx, functionName) {\n      return function () {\n        var result = ctx[functionName].apply(ctx, arguments);\n        var err = ctx.getError();\n        if (err != 0) {\n          glErrorShadow[err] = true;\n          opt_onErrorFunc(err, functionName, arguments);\n        }\n        return result;\n      };\n    }\n\n    // Make a an object that has a copy of every property of the WebGL context\n    // but wraps all functions.\n    var wrapper = {};\n    for (var propertyName in ctx) {\n      if (typeof ctx[propertyName] == 'function') {\n        wrapper[propertyName] = makeErrorWrapper(ctx, propertyName);\n      } else {\n        wrapper[propertyName] = ctx[propertyName];\n      }\n    }\n\n    // Override the getError function with one that returns our saved results.\n    wrapper.getError = function () {\n      for (var err in glErrorShadow) {\n        if (glErrorShadow[err]) {\n          glErrorShadow[err] = false;\n          return err;\n        }\n      }\n      return ctx.NO_ERROR;\n    };\n\n    return wrapper;\n  }\n\n  function resetToInitialState(ctx) {\n    var numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);\n    var tmp = ctx.createBuffer();\n    ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);\n    for (var ii = 0; ii < numAttribs; ++ii) {\n      ctx.disableVertexAttribArray(ii);\n      ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);\n      ctx.vertexAttrib1f(ii, 0);\n    }\n    ctx.deleteBuffer(tmp);\n\n    var numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);\n    for (var ii = 0; ii < numTextureUnits; ++ii) {\n      ctx.activeTexture(ctx.TEXTURE0 + ii);\n      ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);\n      ctx.bindTexture(ctx.TEXTURE_2D, null);\n    }\n\n    ctx.activeTexture(ctx.TEXTURE0);\n    ctx.useProgram(null);\n    ctx.bindBuffer(ctx.ARRAY_BUFFER, null);\n    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);\n    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);\n    ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);\n    ctx.disable(ctx.BLEND);\n    ctx.disable(ctx.CULL_FACE);\n    ctx.disable(ctx.DEPTH_TEST);\n    ctx.disable(ctx.DITHER);\n    ctx.disable(ctx.SCISSOR_TEST);\n    ctx.blendColor(0, 0, 0, 0);\n    ctx.blendEquation(ctx.FUNC_ADD);\n    ctx.blendFunc(ctx.ONE, ctx.ZERO);\n    ctx.clearColor(0, 0, 0, 0);\n    ctx.clearDepth(1);\n    ctx.clearStencil(-1);\n    ctx.colorMask(true, true, true, true);\n    ctx.cullFace(ctx.BACK);\n    ctx.depthFunc(ctx.LESS);\n    ctx.depthMask(true);\n    ctx.depthRange(0, 1);\n    ctx.frontFace(ctx.CCW);\n    ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);\n    ctx.lineWidth(1);\n    ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);\n    ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);\n    ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);\n    ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);\n    // TODO: Delete this IF.\n    if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {\n      ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);\n    }\n    ctx.polygonOffset(0, 0);\n    ctx.sampleCoverage(1, false);\n    ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);\n    ctx.stencilFunc(ctx.ALWAYS, 0, 0xFFFFFFFF);\n    ctx.stencilMask(0xFFFFFFFF);\n    ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);\n    ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);\n    ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);\n\n    // TODO: This should NOT be needed but Firefox fails with 'hint'\n    while (ctx.getError()) {}\n  }\n\n  function makeLostContextSimulatingContext(ctx) {\n    var wrapper_ = {};\n    var contextId_ = 1;\n    var contextLost_ = false;\n    var resourceId_ = 0;\n    var resourceDb_ = [];\n    var onLost_ = undefined;\n    var onRestored_ = undefined;\n    var nextOnRestored_ = undefined;\n\n    // Holds booleans for each GL error so can simulate errors.\n    var glErrorShadow_ = {};\n\n    function isWebGLObject(obj) {\n      //return false;\n      return obj instanceof WebGLBuffer || obj instanceof WebGLFramebuffer || obj instanceof WebGLProgram || obj instanceof WebGLRenderbuffer || obj instanceof WebGLShader || obj instanceof WebGLTexture;\n    }\n\n    function checkResources(args) {\n      for (var ii = 0; ii < args.length; ++ii) {\n        var arg = args[ii];\n        if (isWebGLObject(arg)) {\n          return arg.__webglDebugContextLostId__ == contextId_;\n        }\n      }\n      return true;\n    }\n\n    function clearErrors() {\n      var k = Object.keys(glErrorShadow_);\n      for (var ii = 0; ii < k.length; ++ii) {\n        delete glErrorShdow_[k];\n      }\n    }\n\n    // Makes a function that simulates WebGL when out of context.\n    function makeLostContextWrapper(ctx, functionName) {\n      var f = ctx[functionName];\n      return function () {\n        // Only call the functions if the context is not lost.\n        if (!contextLost_) {\n          if (!checkResources(arguments)) {\n            glErrorShadow_[ctx.INVALID_OPERATION] = true;\n            return;\n          }\n          var result = f.apply(ctx, arguments);\n          return result;\n        }\n      };\n    }\n\n    for (var propertyName in ctx) {\n      if (typeof ctx[propertyName] == 'function') {\n        wrapper_[propertyName] = makeLostContextWrapper(ctx, propertyName);\n      } else {\n        wrapper_[propertyName] = ctx[propertyName];\n      }\n    }\n\n    function makeWebGLContextEvent(statusMessage) {\n      return { statusMessage: statusMessage };\n    }\n\n    function freeResources() {\n      for (var ii = 0; ii < resourceDb_.length; ++ii) {\n        var resource = resourceDb_[ii];\n        if (resource instanceof WebGLBuffer) {\n          ctx.deleteBuffer(resource);\n        } else if (resource instanceof WebctxFramebuffer) {\n          ctx.deleteFramebuffer(resource);\n        } else if (resource instanceof WebctxProgram) {\n          ctx.deleteProgram(resource);\n        } else if (resource instanceof WebctxRenderbuffer) {\n          ctx.deleteRenderbuffer(resource);\n        } else if (resource instanceof WebctxShader) {\n          ctx.deleteShader(resource);\n        } else if (resource instanceof WebctxTexture) {\n          ctx.deleteTexture(resource);\n        }\n      }\n    }\n\n    wrapper_.loseContext = function () {\n      if (!contextLost_) {\n        contextLost_ = true;\n        ++contextId_;\n        while (ctx.getError()) {}\n        clearErrors();\n        glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true;\n        setTimeout(function () {\n          if (onLost_) {\n            onLost_(makeWebGLContextEvent(\"context lost\"));\n          }\n        }, 0);\n      }\n    };\n\n    wrapper_.restoreContext = function () {\n      if (contextLost_) {\n        if (onRestored_) {\n          setTimeout(function () {\n            freeResources();\n            resetToInitialState(ctx);\n            contextLost_ = false;\n            if (onRestored_) {\n              var callback = onRestored_;\n              onRestored_ = nextOnRestored_;\n              nextOnRestored_ = undefined;\n              callback(makeWebGLContextEvent(\"context restored\"));\n            }\n          }, 0);\n        } else {\n          throw \"You can not restore the context without a listener\";\n        }\n      }\n    };\n\n    // Wrap a few functions specially.\n    wrapper_.getError = function () {\n      if (!contextLost_) {\n        var err;\n        while (err = ctx.getError()) {\n          glErrorShadow_[err] = true;\n        }\n      }\n      for (var err in glErrorShadow_) {\n        if (glErrorShadow_[err]) {\n          delete glErrorShadow_[err];\n          return err;\n        }\n      }\n      return ctx.NO_ERROR;\n    };\n\n    var creationFunctions = [\"createBuffer\", \"createFramebuffer\", \"createProgram\", \"createRenderbuffer\", \"createShader\", \"createTexture\"];\n    for (var ii = 0; ii < creationFunctions.length; ++ii) {\n      var functionName = creationFunctions[ii];\n      wrapper_[functionName] = function (f) {\n        return function () {\n          if (contextLost_) {\n            return null;\n          }\n          var obj = f.apply(ctx, arguments);\n          obj.__webglDebugContextLostId__ = contextId_;\n          resourceDb_.push(obj);\n          return obj;\n        };\n      }(ctx[functionName]);\n    }\n\n    var functionsThatShouldReturnNull = [\"getActiveAttrib\", \"getActiveUniform\", \"getBufferParameter\", \"getContextAttributes\", \"getAttachedShaders\", \"getFramebufferAttachmentParameter\", \"getParameter\", \"getProgramParameter\", \"getProgramInfoLog\", \"getRenderbufferParameter\", \"getShaderParameter\", \"getShaderInfoLog\", \"getShaderSource\", \"getTexParameter\", \"getUniform\", \"getUniformLocation\", \"getVertexAttrib\"];\n    for (var ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {\n      var functionName = functionsThatShouldReturnNull[ii];\n      wrapper_[functionName] = function (f) {\n        return function () {\n          if (contextLost_) {\n            return null;\n          }\n          return f.apply(ctx, arguments);\n        };\n      }(wrapper_[functionName]);\n    }\n\n    var isFunctions = [\"isBuffer\", \"isEnabled\", \"isFramebuffer\", \"isProgram\", \"isRenderbuffer\", \"isShader\", \"isTexture\"];\n    for (var ii = 0; ii < isFunctions.length; ++ii) {\n      var functionName = isFunctions[ii];\n      wrapper_[functionName] = function (f) {\n        return function () {\n          if (contextLost_) {\n            return false;\n          }\n          return f.apply(ctx, arguments);\n        };\n      }(wrapper_[functionName]);\n    }\n\n    wrapper_.checkFramebufferStatus = function (f) {\n      return function () {\n        if (contextLost_) {\n          return ctx.FRAMEBUFFER_UNSUPPORTED;\n        }\n        return f.apply(ctx, arguments);\n      };\n    }(wrapper_.checkFramebufferStatus);\n\n    wrapper_.getAttribLocation = function (f) {\n      return function () {\n        if (contextLost_) {\n          return -1;\n        }\n        return f.apply(ctx, arguments);\n      };\n    }(wrapper_.getAttribLocation);\n\n    wrapper_.getVertexAttribOffset = function (f) {\n      return function () {\n        if (contextLost_) {\n          return 0;\n        }\n        return f.apply(ctx, arguments);\n      };\n    }(wrapper_.getVertexAttribOffset);\n\n    wrapper_.isContextLost = function () {\n      return contextLost_;\n    };\n\n    function wrapEvent(listener) {\n      if (typeof listener == \"function\") {\n        return listener;\n      } else {\n        return function (info) {\n          listener.handleEvent(info);\n        };\n      }\n    }\n\n    wrapper_.registerOnContextLostListener = function (listener) {\n      onLost_ = wrapEvent(listener);\n    };\n\n    wrapper_.registerOnContextRestoredListener = function (listener) {\n      if (contextLost_) {\n        nextOnRestored_ = wrapEvent(listener);\n      } else {\n        onRestored_ = wrapEvent(listener);\n      }\n    };\n\n    return wrapper_;\n  }\n\n  return {\n    /**\r\n     * Initializes this module. Safe to call more than once.\r\n     * @param {!WebGLRenderingContext} ctx A WebGL context. If\r\n     *    you have more than one context it doesn't matter which one\r\n     *    you pass in, it is only used to pull out constants.\r\n     */\n    'init': init,\n\n    /**\r\n     * Returns true or false if value matches any WebGL enum\r\n     * @param {*} value Value to check if it might be an enum.\r\n     * @return {boolean} True if value matches one of the WebGL defined enums\r\n     */\n    'mightBeEnum': mightBeEnum,\n\n    /**\r\n     * Gets an string version of an WebGL enum.\r\n     *\r\n     * Example:\r\n     *   WebGLDebugUtil.init(ctx);\r\n     *   var str = WebGLDebugUtil.glEnumToString(ctx.getError());\r\n     *\r\n     * @param {number} value Value to return an enum for\r\n     * @return {string} The string version of the enum.\r\n     */\n    'glEnumToString': glEnumToString,\n\n    /**\r\n     * Converts the argument of a WebGL function to a string.\r\n     * Attempts to convert enum arguments to strings.\r\n     *\r\n     * Example:\r\n     *   WebGLDebugUtil.init(ctx);\r\n     *   var str = WebGLDebugUtil.glFunctionArgToString('bindTexture', 0, gl.TEXTURE_2D);\r\n     *\r\n     * would return 'TEXTURE_2D'\r\n     *\r\n     * @param {string} functionName the name of the WebGL function.\r\n     * @param {number} argumentIndx the index of the argument.\r\n     * @param {*} value The value of the argument.\r\n     * @return {string} The value as a string.\r\n     */\n    'glFunctionArgToString': glFunctionArgToString,\n\n    /**\r\n     * Given a WebGL context returns a wrapped context that calls\r\n     * gl.getError after every command and calls a function if the\r\n     * result is not NO_ERROR.\r\n     *\r\n     * You can supply your own function if you want. For example, if you'd like\r\n     * an exception thrown on any GL error you could do this\r\n     *\r\n     *    function throwOnGLError(err, funcName, args) {\r\n     *      throw WebGLDebugUtils.glEnumToString(err) + \" was caused by call to\" +\r\n     *            funcName;\r\n     *    };\r\n     *\r\n     *    ctx = WebGLDebugUtils.makeDebugContext(\r\n     *        canvas.getContext(\"webgl\"), throwOnGLError);\r\n     *\r\n     * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\r\n     * @param {!function(err, funcName, args): void} opt_onErrorFunc The function\r\n     *     to call when gl.getError returns an error. If not specified the default\r\n     *     function calls console.log with a message.\r\n     */\n    'makeDebugContext': makeDebugContext,\n\n    /**\r\n     * Given a WebGL context returns a wrapped context that adds 4\r\n     * functions.\r\n     *\r\n     * ctx.loseContext:\r\n     *   simulates a lost context event.\r\n     *\r\n     * ctx.restoreContext:\r\n     *   simulates the context being restored.\r\n     *\r\n     * ctx.registerOnContextLostListener(listener):\r\n     *   lets you register a listener for context lost. Use instead\r\n     *   of addEventListener('webglcontextlostevent', listener);\r\n     *\r\n     * ctx.registerOnContextRestoredListener(listener):\r\n     *   lets you register a listener for context restored. Use\r\n     *   instead of addEventListener('webglcontextrestored',\r\n     *   listener);\r\n     *\r\n     * @param {!WebGLRenderingContext} ctx The webgl context to wrap.\r\n     */\n    'makeLostContextSimulatingContext': makeLostContextSimulatingContext,\n\n    /**\r\n     * Resets a context to the initial state.\r\n     * @param {!WebGLRenderingContext} ctx The webgl context to\r\n     *     reset.\r\n     */\n    'resetToInitialState': resetToInitialState\n  };\n};\n\nexports.default = WebGLDebugUtils();\n\n//# sourceURL=webpack:///./src/vendor/webgl/webgl-debug.js?");

/***/ }),

/***/ "./src/vendor/webgl/webgl-utils.js":
/*!*****************************************!*\
  !*** ./src/vendor/webgl/webgl-utils.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\r\n * Copyright 2010, Google Inc.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n *\r\n *     * Redistributions of source code must retain the above copyright\r\n * notice, this list of conditions and the following disclaimer.\r\n *     * Redistributions in binary form must reproduce the above\r\n * copyright notice, this list of conditions and the following disclaimer\r\n * in the documentation and/or other materials provided with the\r\n * distribution.\r\n *     * Neither the name of Google Inc. nor the names of its\r\n * contributors may be used to endorse or promote products derived from\r\n * this software without specific prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\r\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\r\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\r\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\r\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\r\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\r\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\r\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\n\n/**\r\n * @fileoverview This file contains functions every webgl program will need\r\n * a version of one way or another.\r\n *\r\n * Instead of setting up a context manually it is recommended to\r\n * use. This will check for success or failure. On failure it\r\n * will attempt to present an approriate message to the user.\r\n *\r\n *       gl = WebGLUtils.setupWebGL(canvas);\r\n *\r\n * For animated WebGL apps use of setTimeout or setInterval are\r\n * discouraged. It is recommended you structure your rendering\r\n * loop like this.\r\n *\r\n *       function render() {\r\n *         window.requestAnimationFrame(render, canvas);\r\n *\r\n *         // do rendering\r\n *         ...\r\n *       }\r\n *       render();\r\n *\r\n * This will call your rendering function up to the refresh rate\r\n * of your display but will stop rendering if your app is not\r\n * visible.\r\n */\n\nvar WebGLUtils = function WebGLUtils() {\n\n  /**\r\n   * Creates the HTLM for a failure message\r\n   * @param {string} canvasContainerId id of container of th\r\n   *        canvas.\r\n   * @return {string} The html.\r\n   */\n  var makeFailHTML = function makeFailHTML(msg) {\n    return '' + '<div style=\"margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;\">' + msg + '</div>';\n    return '' + '<table style=\"background-color: #8CE; width: 100%; height: 100%;\"><tr>' + '<td align=\"center\">' + '<div style=\"display: table-cell; vertical-align: middle;\">' + '<div style=\"\">' + msg + '</div>' + '</div>' + '</td></tr></table>';\n  };\n\n  /**\r\n   * Mesasge for getting a webgl browser\r\n   * @type {string}\r\n   */\n  var GET_A_WEBGL_BROWSER = '' + 'This page requires a browser that supports WebGL.<br/>' + '<a href=\"http://get.webgl.org\">Click here to upgrade your browser.</a>';\n\n  /**\r\n   * Mesasge for need better hardware\r\n   * @type {string}\r\n   */\n  var OTHER_PROBLEM = '' + \"It doesn't appear your computer can support WebGL.<br/>\" + '<a href=\"http://get.webgl.org\">Click here for more information.</a>';\n\n  /**\r\n   * Creates a webgl context. If creation fails it will\r\n   * change the contents of the container of the <canvas>\r\n   * tag to an error message with the correct links for WebGL.\r\n   * @param {Element} canvas. The canvas element to create a\r\n   *     context from.\r\n   * @param {WebGLContextCreationAttirbutes} opt_attribs Any\r\n   *     creation attributes you want to pass in.\r\n   * @param {function:(msg)} opt_onError An function to call\r\n   *     if there is an error during creation.\r\n   * @return {WebGLRenderingContext} The created context.\r\n   */\n  var setupWebGL = function setupWebGL(canvas, opt_attribs, opt_onError) {\n    function handleCreationError(msg) {\n      var container = document.getElementsByTagName(\"body\")[0];\n      //var container = canvas.parentNode;\n      if (container) {\n        var str = window.WebGLRenderingContext ? OTHER_PROBLEM : GET_A_WEBGL_BROWSER;\n        if (msg) {\n          str += \"<br/><br/>Status: \" + msg;\n        }\n        container.innerHTML = makeFailHTML(str);\n      }\n    };\n\n    opt_onError = opt_onError || handleCreationError;\n\n    if (canvas.addEventListener) {\n      canvas.addEventListener(\"webglcontextcreationerror\", function (event) {\n        opt_onError(event.statusMessage);\n      }, false);\n    }\n    var context = create3DContext(canvas, opt_attribs);\n    if (!context) {\n      if (!window.WebGLRenderingContext) {\n        opt_onError(\"\");\n      } else {\n        opt_onError(\"\");\n      }\n    }\n\n    return context;\n  };\n\n  /**\r\n   * Creates a webgl context.\r\n   * @param {!Canvas} canvas The canvas tag to get context\r\n   *     from. If one is not passed in one will be created.\r\n   * @return {!WebGLContext} The created context.\r\n   */\n  var create3DContext = function create3DContext(canvas, opt_attribs) {\n    var names = [\"webgl\", \"experimental-webgl\", \"webkit-3d\", \"moz-webgl\"];\n    var context = null;\n    for (var ii = 0; ii < names.length; ++ii) {\n      try {\n        context = canvas.getContext(names[ii], opt_attribs);\n      } catch (e) {}\n      if (context) {\n        break;\n      }\n    }\n    return context;\n  };\n\n  return {\n    create3DContext: create3DContext,\n    setupWebGL: setupWebGL\n  };\n};\n\n/**\r\n * Provides requestAnimationFrame in a cross browser\r\n * way.\r\n */\nif (!window.requestAnimationFrame) {\n  window.requestAnimationFrame = function () {\n    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( /* function FrameRequestCallback */callback, /* DOMElement Element */element) {\n      window.setTimeout(callback, 1000 / 60);\n    };\n  }();\n}\n\n/** * ERRATA: 'cancelRequestAnimationFrame' renamed to 'cancelAnimationFrame' to reflect an update to the W3C Animation-Timing Spec. \r\n * \r\n * Cancels an animation frame request. \r\n * Checks for cross-browser support, falls back to clearTimeout. \r\n * @param {number}  Animation frame request. */\nif (!window.cancelAnimationFrame) {\n  window.cancelAnimationFrame = window.cancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.clearTimeout;\n}\n\nexports.default = WebGLUtils();\n\n//# sourceURL=webpack:///./src/vendor/webgl/webgl-utils.js?");

/***/ }),

/***/ "./src/views/fpviewer/buffer.js":
/*!**************************************!*\
  !*** ./src/views/fpviewer/buffer.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar initArrayBuffer = function initArrayBuffer(gl, data, num, type, attribute) {\n\tvar buffer = gl.createBuffer();\n\tif (!buffer) {\n\t\tconsole.log(\"not create buffer\");\n\t\treturn false;\n\t}\n\tgl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n\tgl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);\n\n\tvar a_attribute = gl.getAttribLocation(gl.program, attribute);\n\tif (a_attribute < 0) {\n\t\tconsole.log(\"not find attribute\");\n\t\treturn false;\n\t}\n\n\tgl.vertexAttribPointer(a_attribute, num, type, false, 0, 0);\n\tgl.enableVertexAttribArray(a_attribute);\n\n\treturn true;\n};\n\n/**\n * 初始化vertexBuffer对象\n * @param  {[type]} gl [description]\n * @return {[type]}    [description]\n */\nvar initVertexBuffers = function initVertexBuffers(gl, data) {\n\t// 创建缓冲区对象\n\tvar indexBuffer = gl.createBuffer();\n\tif (!indexBuffer) {\n\t\tconsole.log('not create buffer object');\n\t\treturn false;\n\t}\n\n\tif (!initArrayBuffer(gl, data.vertices, 3, gl.FLOAT, 'a_Position')) return -1;\n\tif (!initArrayBuffer(gl, data.texCoords, 2, gl.FLOAT, 'a_TexCoord')) return -1;\n\n\tgl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\n\tgl.bufferData(gl.ELEMENT_ARRAY_BUFFER, data.indices, gl.STATIC_DRAW);\n\n\treturn true;\n};\n\nexports.default = initVertexBuffers;\n\n//# sourceURL=webpack:///./src/views/fpviewer/buffer.js?");

/***/ }),

/***/ "./src/views/fpviewer/click_rotate_obj.js":
/*!************************************************!*\
  !*** ./src/views/fpviewer/click_rotate_obj.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * 适配pc与移动端的鼠标事件\n * @param  {[type]} element [description]\n * @param  {[type]} type    [description]\n * @param  {[type]} handler [description]\n * @return {[type]}         [description]\n */\nvar addHandler = function addHandler(element, type, handler) {\n  if (element.addEventListener) {\n    element.addEventListener(type, handler, true);\n  } else if (element.attachEvent) {\n    element.attachEvent(\"on\" + type, handler);\n  } else {\n    element[\"on\" + type] = handler;\n  }\n};\n\n/**\n * 初始化鼠标拖拽事件\n * @param  {[type]} canvas       [description]\n * @param  {[type]} currentAngle [description]\n * @return {[type]}              [description]\n */\nvar initEventHandlers = function initEventHandlers(canvas, currentAngle) {\n  // 默认不拖拽\n  var dragging = false;\n  // 初始化鼠标最终移动位置坐标\n  var lastX = -1,\n      lastY = -1;\n\n  var down = 'ontouchstart' in canvas ? 'touchstart' : 'mousedown';\n  addHandler(canvas, down, function (e) {\n    var ev = 'ontouchstart' in canvas ? e.touches[0] : e;\n    var x = ev.clientX,\n        y = ev.clientY;\n    // 鼠标在canvas内拖动, 获取canvas当前坐标数据\n    var rect = ev.target.getBoundingClientRect();\n    // 锁定canvas范围内\n    if (rect.left <= x && x < rect.right && rect.top <= y && y < rect.bottom) {\n      lastX = x;lastY = y;\n      dragging = true;\n    }\n  });\n\n  var move = 'ontouchmove' in canvas ? 'touchmove' : 'mousemove';\n  addHandler(canvas, move, function (e) {\n    var ev = 'ontouchmove' in canvas ? e.touches[0] : e;\n    var x = ev.clientX,\n        y = ev.clientY;\n    if (dragging) {\n      var factor = 100 / canvas.height; // 旋转因子 \n      var dx = factor * (x - lastX);\n      var dy = factor * (y - lastY);\n      // 控制Y轴旋转角度在-90至90度之间，防止万向锁问题\n      currentAngle[0] = Math.max(Math.min(currentAngle[0] + dy, 90.0), -90.0);\n      currentAngle[1] = currentAngle[1] + dx;\n    }\n    lastX = x, lastY = y;\n  });\n\n  var up = 'ontouchend' in canvas ? 'touchend' : 'mouseup';\n  addHandler(canvas, up, function (e) {\n    dragging = false;\n  });\n};\n\nexports.default = initEventHandlers;\n\n//# sourceURL=webpack:///./src/views/fpviewer/click_rotate_obj.js?");

/***/ }),

/***/ "./src/views/fpviewer/data.js":
/*!************************************!*\
  !*** ./src/views/fpviewer/data.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\n// import niutouObj from \"res_gl/model/niutou.obj.js\";\n// const OBJ = require('webgl-obj-loader');\n\nvar initNiuModelData = exports.initNiuModelData = function initNiuModelData() {\n  // console.log(niutouObj);\n  // var mesh = new OBJ.Mesh(niutouObj);\n  // console.log(mesh);\n};\n\nvar initCubeData = exports.initCubeData = function initCubeData() {\n  // Create a cube\n  //    v6----- v5\n  //   /|      /|\n  //  v1------v0|\n  //  | |     | |\n  //  | |v7---|-|v4\n  //  |/      |/\n  //  v2------v3\n  var vertices = new Float32Array([// Vertex coordinates\n  1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, 1.0, // v0-v1-v2-v3 front\n  1.0, 1.0, 1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, 1.0, 1.0, -1.0, // v0-v3-v4-v5 right\n  1.0, 1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, 1.0, // v0-v5-v6-v1 up\n  -1.0, 1.0, 1.0, -1.0, 1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, // v1-v6-v7-v2 left\n  -1.0, -1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, -1.0, -1.0, 1.0, // v7-v4-v3-v2 down\n  1.0, -1.0, -1.0, -1.0, -1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0 // v4-v7-v6-v5 back\n  ]);\n\n  var texCoords = new Float32Array([// Texture coordinates\n  1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v0-v1-v2-v3 front\n  0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 1.0, 1.0, // v0-v3-v4-v5 right\n  1.0, 0.0, 1.0, 1.0, 0.0, 1.0, 0.0, 0.0, // v0-v5-v6-v1 up\n  1.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, // v1-v6-v7-v2 left\n  0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0, // v7-v4-v3-v2 down\n  0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0 // v4-v7-v6-v5 back\n  ]);\n\n  // Indices of the vertices\n  var indices = new Uint8Array([0, 1, 2, 0, 2, 3, // front\n  4, 5, 6, 4, 6, 7, // right\n  8, 9, 10, 8, 10, 11, // up\n  12, 13, 14, 12, 14, 15, // left\n  16, 17, 18, 16, 18, 19, // down\n  20, 21, 22, 20, 22, 23 // back\n  ]);\n\n  return { vertices: vertices, texCoords: texCoords, indices: indices };\n};\n\n//# sourceURL=webpack:///./src/views/fpviewer/data.js?");

/***/ }),

/***/ "./src/views/fpviewer/index.js":
/*!*************************************!*\
  !*** ./src/views/fpviewer/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _cuonUtils = __webpack_require__(/*! vendor_gl/cuon-utils */ \"./src/vendor/webgl/cuon-utils.js\");\n\nvar _cuonMatrix = __webpack_require__(/*! vendor_gl/cuon-matrix */ \"./src/vendor/webgl/cuon-matrix.js\");\n\nvar _TestShader = __webpack_require__(/*! shader_gl/fpviewer/TestShader */ \"./src/components/shader/fpviewer/TestShader.js\");\n\nvar _TestShader2 = _interopRequireDefault(_TestShader);\n\nvar _buffer = __webpack_require__(/*! fpviewer/buffer */ \"./src/views/fpviewer/buffer.js\");\n\nvar _buffer2 = _interopRequireDefault(_buffer);\n\nvar _data = __webpack_require__(/*! fpviewer/data */ \"./src/views/fpviewer/data.js\");\n\nvar _texture = __webpack_require__(/*! fpviewer/texture */ \"./src/views/fpviewer/texture.js\");\n\nvar _texture2 = _interopRequireDefault(_texture);\n\nvar _click_rotate_obj = __webpack_require__(/*! fpviewer/click_rotate_obj */ \"./src/views/fpviewer/click_rotate_obj.js\");\n\nvar _click_rotate_obj2 = _interopRequireDefault(_click_rotate_obj);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// 记录立方体的变换矩阵\nvar g_MVPMatrix = new _cuonMatrix.Matrix4();\n// camera view point\nvar cameraPos = new _cuonMatrix.Vector3([3.0, 3.0, 7.0]);\nvar distance = Math.pow(cameraPos.elements[0], 2) + Math.pow(cameraPos.elements[1], 2) + Math.pow(cameraPos.elements[2], 2);\n\n// 自定义视场宽度\nvar customViewWidth = 56;\n\nvar gl = void 0,\n    canvas = void 0,\n    viewMatrix = void 0;\n\nvar fpviewer = function fpviewer(resolve, reject) {\n\n\tcanvas = document.createElement(\"canvas\");\n\n\tif (!canvas) {\n\t\tconsole.log(\"no read element\");\n\t\treject();\n\t}\n\tcanvas.width = window.innerWidth;\n\tcanvas.height = window.innerHeight;\n\n\tgl = (0, _cuonUtils.getWebGLContext)(canvas);\n\tif (!gl) {\n\t\tconsole.log('no read rendering context for webgl');\n\t\treject();\n\t}\n\n\tif (!(0, _cuonUtils.initShaders)(gl, _TestShader2.default.vertexShader, _TestShader2.default.fragmentShader)) {\n\t\tconsole.log('Failed to intialize shaders.');\n\t\treject();\n\t}\n\n\tvar modelData = (0, _data.initCubeData)();\n\tvar dataNum = modelData.indices.length;\n\n\tif (!(0, _buffer2.default)(gl, modelData)) {\n\t\tconsole.log(\"failed to set vertices\");\n\t\treject();\n\t}\n\n\tgl.clearColor(0.0, 0.0, 0.0, 1.0);\n\tgl.enable(gl.DEPTH_TEST);\n\n\tvar u_MVPMatrix = gl.getUniformLocation(gl.program, 'u_MVPMatrix');\n\n\tviewMatrix = new _cuonMatrix.Matrix4();\n\t// 适配多种屏幕\n\tvar fov = calcFov(distance, customViewWidth, canvas.width / canvas.height);\n\tviewMatrix.setPerspective(fov, canvas.width / canvas.height, 0.1, 1000.0);\n\tviewMatrix.lookAt(cameraPos.elements[0], cameraPos.elements[1], cameraPos.elements[2], 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\n\tvar currentAngle = [0.0, 0.0]; // [绕x轴旋转角度，绕y轴旋转角度]\n\t(0, _click_rotate_obj2.default)(canvas, currentAngle);\n\n\tif (!(0, _texture2.default)(gl, dataNum)) {\n\t\tconsole.log(\"not intialize texture\");\n\t\treject();\n\t}\n\n\t// 加载牛头模型\n\t// initNiuModelData();\n\n\tvar tick = function tick() {\n\t\tdraw(gl, dataNum, viewMatrix, u_MVPMatrix, currentAngle);\n\t\trequestAnimationFrame(tick);\n\t};\n\ttick();\n\n\twindow.addEventListener('resize', resizeWindows, false);\n\n\tresolve(canvas);\n};\n\nvar draw = function draw(gl, n, viewMatrix, u_MVPMatrix, currentAngle) {\n\tg_MVPMatrix.set(viewMatrix);\n\tg_MVPMatrix.rotate(currentAngle[0], 1.0, 0.0, 0.0);\n\tg_MVPMatrix.rotate(currentAngle[1], 0.0, 1.0, 0.0);\n\n\tgl.uniformMatrix4fv(u_MVPMatrix, false, g_MVPMatrix.elements);\n\n\tgl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n\n\tgl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);\n};\n\n/**\n * 计算相机 fov 的函数\n * @param d : 在相机前方 d 距离\n * @param w : 想要看到最大正方形区域边长为 w\n * @param r : 屏幕宽高比\n */\nfunction calcFov(d, w, r) {\n\tvar f;\n\tvar vertical = w;\n\tif (r < 1) {\n\t\tvertical = vertical / r;\n\t}\n\tf = Math.atan(vertical / d / 2) * 2 * (180 / Math.PI);\n\treturn f;\n}\n\nvar resizeWindows = function resizeWindows() {\n\tcanvas.width = window.innerWidth;\n\tcanvas.height = window.innerHeight;\n\t// 适配多种屏幕\n\tvar fov = calcFov(distance, customViewWidth, canvas.width / canvas.height);\n\tviewMatrix.setPerspective(fov, canvas.width / canvas.height, 0.1, 1000.0);\n\tviewMatrix.lookAt(3.0, 3.0, 7.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0);\n\tgl.viewport(0, 0, canvas.width, canvas.height);\n};\n\nexports.default = fpviewer;\n\n//# sourceURL=webpack:///./src/views/fpviewer/index.js?");

/***/ }),

/***/ "./src/views/fpviewer/texture.js":
/*!***************************************!*\
  !*** ./src/views/fpviewer/texture.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n\tvalue: true\n});\n\nvar _sky = __webpack_require__(/*! res_gl/img/sky.jpg */ \"./src/assets/img/sky.jpg\");\n\nvar _sky2 = _interopRequireDefault(_sky);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar loadTexture = function loadTexture(gl, n, texture, u_Sampler, image) {\n\t// y轴翻转图片\n\tgl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);\n\t// 激活0号纹理\n\tgl.activeTexture(gl.TEXTURE0);\n\t// 绑定成2D纹理\n\tgl.bindTexture(gl.TEXTURE_2D, texture);\n\n\t// 设置纹理参数\n\tgl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n\n\t// 测试其他的纹理填充模式\n\t// 垂直方向镜像重复填充\n\t// gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.MIRRORED_REPEAT);\n\t// // 水平方向去取边缘值作为填充值\n\t// \tgl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n\n\t// 设置纹理图像参数\n\tgl.texImage2D(gl.TEXTURE_2D, 0, gl.RGB, gl.RGB, gl.UNSIGNED_BYTE, image);\n\n\t// 将纹理单元设置到采样器对象\n\tgl.uniform1i(u_Sampler, 0);\n};\n\nvar initTexture = function initTexture(gl, num) {\n\t// 创建纹理对象\n\tvar texture = gl.createTexture();\n\tif (!texture) {\n\t\tconsole.log(\"not create texture object\");\n\t\treturn false;\n\t}\n\n\tvar u_Sampler = gl.getUniformLocation(gl.program, 'u_Sampler');\n\n\tvar image = new Image();\n\timage.onload = function () {\n\t\tloadTexture(gl, num, texture, u_Sampler, image);\n\t};\n\timage.src = _sky2.default;\n\n\treturn true;\n};\n\nexports.default = initTexture;\n\n//# sourceURL=webpack:///./src/views/fpviewer/texture.js?");

/***/ })

/******/ });