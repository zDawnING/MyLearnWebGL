<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
	<title>基础场景设置</title>
</head>
<style type="text/css">
	body{
		/*设置全屏*/
		margin: 0;
		overflow: hidden;
	}
</style>
<body>

	<div id="stats-output"></div>
	<div id="webgl-output"></div>
	
	<script type="text/javascript" src="../lib/three.js"></script>
	<script type="text/javascript" src="../lib/stats.js"></script>
	<!-- 相机控制 -->
	<script type="text/javascript" src="../lib/controls/OrbitControls.js"></script>
	<!-- ammo.js的包装器，属于简单应用引擎的threejs插件 -->
	<script type="text/javascript" src="../lib/physi.js"></script>
	<!-- 这里加入颜色处理器，生成指定范围并好看的颜色, 并进行各种格式的转换 -->
	<script type="text/javascript" src="../lib/chroma.js"></script>
	<!-- 噪音生成器 -->
	<script type="text/javascript" src="../lib/perlin.js"></script>

	<script type="text/javascript" src="../lib/dat.gui.js"></script>

	<script type="text/javascript">
		// Physijs 只是ammo.js的一个包装器，ammo.js是基于bullet physics物理引擎直接编译过来的js文件
		// 引入H5的web workers(网页线程)，使引擎可以在一个单独的线程里执行cpu密集的任务，从而不影响渲染
		Physijs.scripts.worker = '../lib/physijs_worker.js';
    Physijs.scripts.ammo = '../lib/ammo.js';

	</script>

	<script type="text/javascript">
		
		// 定义全局变量
		var camera; // 相机
		var scene; // 场景对象
		var renderer; // 渲染器
		// 辅助组件
		var stats; // 检测动画运行帧频
		var gui; // 控制界面变量的组件

		// 场景对象(放置全局方便特殊处理)
		var ground, meshs = [];
		// 场景相关控制变量
		var step = 0, direction = 1, fallDownHight = 15; // 记录增量
    var controls,
    		materialContr;
    var clock;
    var orbitControls;
    // 指定生成颜色的范围
    var colorScale = chroma.scale(['white', 'blue', 'red', 'yellow']);

    /**
     * ===============================
     * 目前经过测试：这套东西的问题主要有：
     * 1. 当场景中所有加载完成后，如果地面是静态的，当其他物体生成至场景中后，再转动地面，则会产生一些相交检测bug，
     * 因此解决方案是地面如果是先静态后动态，最好的方式是不先转动地面，再生成物体，这样一来相交检测的问题即可解决
     * 2. 尽量避免地面角度变化太快，这样会导致物体与地面间的相交性检测运行不过来，而出现一些穿透、弹跳现象。
     * 3. 动态改变已经生产的物体材质会目前没有看到有有效的方法。
     * 
     * ===============================
     */

    /**
     * 初始化控制器
     * @return {[type]} [description]
     */
    function initControler(){
    	controls = new function () {
    		this.groundType = "plane";
    		this.selectPlaneGround = function(){
    			controls.groundType = "plane";
    			scene.remove(ground);
    			controls.clearMesh();

    			createGround();
    		}
    		this.selectHightMapGround = function(){
    			controls.groundType = "hightMap";
    			scene.remove(ground);
    			controls.clearMesh();

    			var date = new Date();
          var pn = new Perlin('rnd' + date.getTime());
    			createHightMapGround(pn);
    		}

    		this.gravityX = 0;
        this.gravityY = -50;
        this.gravityZ = 0;
        this.startDomino = function(){
        	pushFirstDomino();
        }
        // 使地面倾斜 22.5°
	    	this.rotationSpeed = 0.0005;
	    	this.slopeGround = false;
	    	this.resetGround = function(){
	    		controls.slopeGround = false;
	    		step = 0;
	    		if(controls.groundType == 'plane'){
	    			ground.rotation.z = step ;
	    		}else if(controls.groundType == 'hightMap'){
	    			ground.rotation.y = step;
	    		}
	    		ground.__dirtyRotation = true;
	    	}
	    	this.loadDominos = function(){
	    		var points = createPoints();
	    		loadDominoObjects(points);
	    	}
	    	this.addSphere = function(){
	    		addRandomSpheres();
	    	}
	    	this.addCube = function(){
	    		addRandomCubes();
	    	}
	    	this.addCylinder = function(){
	    		addRandomCylinders();
	    	}
	    	this.addCone = function(){
	    		addRandomCones();
	    	}
	    	this.addCapsules = function(){
	    		addRandomCapsules();
	    	}
	    	this.addConvexs = function(){
	    		addRandomConvexs();
	    	}
	    	this.clearMesh = function(){
	    		meshs.forEach(function(e){
	    			scene.remove(e);
	    		})
	    		meshs = [];
	    	}
	    };
	    materialContr = new function(){
	    	// Friction: 摩擦力系数
	    	// Restitution: 回弹系数
	    	this.cubeFriction = 0.9;  // 地面高摩擦,低回弹
	    	this.cubeRestitution = 0.3; 
	    	this.sphereFriction = 0.1;  // 球体低摩擦，高回弹
	    	this.sphereRestitution = 0.9;
	    	
	    	this.updatePlaneMaterial = function(){
	    		// 暂时测试出对已生成的材质修改是失效的
	    		// ground.material._physijs.friction = materialContr.planeFriction;
	    		// ground.material._physijs.restitution = materialContr.planeRestitution;
	    		// ground.material.needsUpdate = true;
	    	}
	    }

    	gui = new dat.GUI();
    	gui.add(controls, 'groundType').listen();
    	gui.add(controls, 'selectPlaneGround');
    	gui.add(controls, 'selectHightMapGround');
    	gui.add(controls, 'startDomino');
    	
    	gui.add(controls, 'loadDominos');
    	gui.add(controls, 'addCube');
    	gui.add(controls, 'addSphere');
    	gui.add(controls, 'addCylinder');
    	gui.add(controls, 'addCone');
    	gui.add(controls, 'addCapsules');
    	gui.add(controls, 'addConvexs');

    	gui.add(controls, 'clearMesh');

    	var groundFolder = gui.addFolder("Ground Controls");
    	groundFolder.add(controls, 'rotationSpeed', 0, 0.005);
    	// 注意：这里虽然可以尝试使用动态调整角度测试效果，经测试地面角度变化太快容易卡bug（即相交检测有问题）
    	// 所以方法中的角度变换采用递增式变化
    	groundFolder.add(controls, 'slopeGround').listen();
    	groundFolder.add(controls, 'resetGround');

    	var gravityFolder = gui.addFolder("Gravity Controls");
    	gravityFolder.add(controls, 'gravityX', -100, 100).onChange(setSceneGravity);
    	gravityFolder.add(controls, 'gravityY', -100, 100).onChange(setSceneGravity);
    	gravityFolder.add(controls, 'gravityZ', -100, 100).onChange(setSceneGravity);

    	var materialFolder = gui.addFolder("Material Controls");
    	materialFolder.add(materialContr, 'cubeFriction', 0, 1);
    	materialFolder.add(materialContr, 'cubeRestitution', 0, 1);
    	materialFolder.add(materialContr, 'sphereFriction', 0, 1);
    	materialFolder.add(materialContr, 'sphereRestitution', 0, 1);
    }

    /**
     * 渲染
     * @return {[type]} [description]
     */
    function render(){
    	var delta = clock.getDelta();
    	stats.update(); // 即时更新FPS
    	
    	orbitControls.update(delta);

    	// 启动旋转地面
    	if(controls.slopeGround){
    		step += controls.rotationSpeed * direction;
    		if(step >= Math.PI/6) direction = -1;
    		if(step <= -Math.PI/6) direction = 1;
    		if(controls.groundType == 'plane'){
    			ground.rotation.z = step ;
    		}else if(controls.groundType == 'hightMap'){
    			ground.rotation.y = step;
    		}
				ground.__dirtyRotation = true;
    	}

    	scene.simulate(undefined, 1);

    	// 使用帧动画函数
    	requestAnimationFrame(render);
    	renderer.render( scene, camera );
    }

		/**
		 * 初始化所有配置
		 * @return {[type]} [description]
		 */
		function init(){
			// 初始化组件
			var stats = initStats();

			// 创建场景, 这里的场景创建要使用Physijs的scene对象
			scene = new Physijs.Scene; // 创建了一个已经应用了物理的场景
			scene.setGravity(new THREE.Vector3( 0, -10, 0 )); // 设置了y轴方向的重力，创建的对象会竖直下落

			// 创建相机
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );
			camera.position.x = -30;
			camera.position.y = 30;
			camera.position.z = 30;
			camera.lookAt(scene.position); // 视线指向场景中心
			// 创建渲染器
			renderer = new THREE.WebGLRenderer();

			// 擦除背景色
			renderer.setClearColor(new THREE.Color( 0xEEEEEE, 1.0 ));
			renderer.setSize(window.innerWidth, window.innerHeight); // 设置视口大小
			renderer.shadowMapEnabled = true; // 启用阴影贴图

			// 配置控制器
			initControler();

			// 展示辅助观察的世界坐标系
      var axes = new THREE.AxisHelper(20);
      scene.add(axes);

      clock = new THREE.Clock();

      orbitControls = new THREE.OrbitControls(camera);

      createGround();

      // var points = createPoints();

      setSceneGravity();

      // loadDominoObjects(points);

			// 添加环境光
			var ambientLight = new THREE.AmbientLight( 0x0C0C0C );
			scene.add(ambientLight);

			// 添加点光源,作为产生阴影的光源
			var spotLight = new THREE.SpotLight(0xFFFFFF);
			spotLight.position.set(-40, 60, -10);
			spotLight.castShadow = true;
			scene.add(spotLight);

			// 把渲染内容输出至dom中
			document.getElementById("webgl-output").appendChild(renderer.domElement);

			
			// 开始渲染
			render();
		}

		/**
		 * 随机生成多个立方体
		 */
		function addRandomCubes(){
			var cubeColor = colorScale(Math.random()).hex();
			// 随机生成数目限制在2~5之间
			var randomNum = Math.abs(Math.floor(Math.random() * 10) - 5);
			randomNum = randomNum < 2 ? 2 : randomNum;
			for(var i=0; i < randomNum; i++){
				var geometry = new THREE.BoxGeometry( 2, 2, 2 );
				var material = new Physijs.createMaterial(new THREE.MeshPhongMaterial({
					color: cubeColor
				}), materialContr.cubeFriction, materialContr.cubeRestitution);
				// 随机质量(暂时该属性不确认是质量，后面研究源码后再处理)
				// var mass =  Math.abs(Math.floor(Math.random() * 40) - 10); // 10~30
				var cube = new Physijs.BoxMesh(geometry, material);
				startRandomPosition(cube);
				scene.add(cube);
				meshs.push(cube);
			}
		}

		/**
		 * 随机生成多个球体
		 */
		function addRandomSpheres(){
			var sphereColor = colorScale(Math.random()).hex();
			// 随机生成数目限制在2~5之间
			var randomNum = Math.abs(Math.floor(Math.random() * 10) - 5);
			randomNum = randomNum < 2 ? 2 : randomNum;
			for(var i=0; i < randomNum; i++){
				var geometry = new THREE.SphereGeometry( 1, 20, 20 );
				var material = new Physijs.createMaterial(new THREE.MeshPhongMaterial({
					color: sphereColor
				}), materialContr.sphereFriction, materialContr.sphereRestitution);
				// 随机质量(暂时该属性不确认是质量，后面研究源码后再处理)
				// var mass =  Math.abs(Math.floor(Math.random() * 40) - 10); // 10~30
				var sphere = new Physijs.SphereMesh(geometry, material);
				startRandomPosition(sphere);
				scene.add(sphere);
				meshs.push(sphere);
			}
		}

		/**
		 * 随机生成多个柱状图形（CylinderMesh 使用于一般的，上下大小一致的）
		 */
		function addRandomCylinders(){
			var color = colorScale(Math.random()).hex();
			// 随机生成数目限制在2~5之间
			var randomNum = Math.abs(Math.floor(Math.random() * 10) - 5);
			randomNum = randomNum < 2 ? 2 : randomNum;
			for(var i=0; i < randomNum; i++){
				var geometry = new THREE.CylinderGeometry( 1.5, 1.5, 4 );
				var material = new Physijs.createMaterial(new THREE.MeshPhongMaterial({
					color: color
				}), materialContr.cubeFriction, materialContr.cubeRestitution);
				var mesh = new Physijs.CylinderMesh(geometry, material);
				startRandomPosition(mesh);
				scene.add(mesh);
				meshs.push(mesh);
			}
		}

		/**
		 * 随机生成多个圆锥体（ConeMesh 使用上下大小不一致的）
		 */
		function addRandomCones(){
			var color = colorScale(Math.random()).hex();
			// 随机生成数目限制在2~5之间
			var randomNum = Math.abs(Math.floor(Math.random() * 10) - 5);
			randomNum = randomNum < 2 ? 2 : randomNum;
			for(var i=0; i < randomNum; i++){
				var geometry = new THREE.CylinderGeometry( 0, 2, 5, 15, 6 );
				var material = new Physijs.createMaterial(new THREE.MeshPhongMaterial({
					color: color
				}), materialContr.cubeFriction, materialContr.cubeRestitution);
				var mesh = new Physijs.ConeMesh(geometry, material);
				startRandomPosition(mesh);
				scene.add(mesh);
				meshs.push(mesh);
			}
		}

		/**
		 * 随机生成多个由多个几何体组合而成的胶囊体（CapsuleMesh 使用跟CylinderMesh类似）
		 */
		function addRandomCapsules(){
			var color = colorScale(Math.random()).hex();
			// 随机生成数目限制在2~5之间
			var randomNum = Math.abs(Math.floor(Math.random() * 10) - 5);
			randomNum = randomNum < 2 ? 2 : randomNum;
			for(var i=0; i < randomNum; i++){
				var mergeGeom = new THREE.Geometry();
				// 创建好要合并的几何对象
				var cylinderGeom = new THREE.CylinderGeometry(1, 1, 4);
        var topSphereGeom = new THREE.SphereGeometry(1);
        var bottomSphereGeom = new THREE.SphereGeometry(1);
        // 分别给在合并几何体过程中哪些需要进行相对位移/旋转的对象生成变换矩阵
        var matrix1 = new THREE.Matrix4().makeTranslation(0, 2, 0);
        var matrix2 = new THREE.Matrix4().makeTranslation(0, -2, 0);
        topSphereGeom.applyMatrix(matrix1);
        bottomSphereGeom.applyMatrix(matrix2);
        // 合并图形
        mergeGeom.merge(topSphereGeom);
        mergeGeom.merge(bottomSphereGeom);
        mergeGeom.merge(cylinderGeom);

				var material = new Physijs.createMaterial(new THREE.MeshPhongMaterial({
					color: color
				}), materialContr.sphereFriction, materialContr.sphereRestitution);
				var mesh = new Physijs.CapsuleMesh(mergeGeom, material);
				startRandomPosition(mesh);
				scene.add(mesh);
				meshs.push(mesh);
			}
		}

		/**
		 * 随机生成多个凸包（ConvexMesh 可用于多数的复杂图形，可以创建一个模拟复杂图形的凸包）
		 */
		function addRandomConvexs(){
			var color = colorScale(Math.random()).hex();
			// 随机生成数目限制在2~5之间
			var randomNum = Math.abs(Math.floor(Math.random() * 10) - 5);
			randomNum = randomNum < 2 ? 2 : randomNum;
			for(var i=0; i < randomNum; i++){
				var geometry = new THREE.TorusKnotGeometry( 0.5, 0.3, 64, 8, 2, 3, 10 );
				var material = new Physijs.createMaterial(new THREE.MeshPhongMaterial({
					color: color
				}), materialContr.cubeFriction, materialContr.cubeRestitution);
				var mesh = new Physijs.ConvexMesh(geometry, material);
				startRandomPosition(mesh);
				scene.add(mesh);
				meshs.push(mesh);
			}
		}

		/**
		 * 设置物体在随机位置
		 * @param  {[type]} obj [description]
		 * @return {[type]}     [description]
		 */
		function startRandomPosition(obj){
			// 指定同一高度下落，观察质量不同的小球的反应（建立在可以设定质量的情况下）
			obj.position.set(Math.random() * 50 - 25, fallDownHight, Math.random() * 50 - 25);
		}

		function pushFirstDomino(){
			dominos[0].rotation.z = -0.4; // 这里的旋转轴不对，后面再更改得自然些
			dominos[0].__dirtyRotation = true; // 开启不自由转动开关，即可直接改变某个物体对象的旋转状态
		}

		/**
		 * 给场景设置重力
		 */
		function setSceneGravity(){
			scene.setGravity(new THREE.Vector3(controls.gravityX, controls.gravityY, controls.gravityZ));
		}

		/**
		 * 加载多米诺骨牌
		 * @return {[type]} [description]
		 */
		function loadDominoObjects(points){
			points.forEach(function(point){
				var geometry = new THREE.BoxGeometry(0.6, 6, 2);
				var material = new Physijs.createMaterial(new THREE.MeshPhongMaterial({
					color: Math.random() * 0xFFFFFF,
					opacity: 0.9,
					transparent: true
				}), 0.4, 0.4); // 这里设置摩擦力和回弹都偏中
				var domino = new Physijs.BoxMesh(geometry, material); // 这里也不设置质量
				domino.position.copy(point);
				domino.position.y = 3.5; // 确保骨牌底部贴紧地面
				domino.lookAt(new THREE.Vector3(0, 3.5, 0)); // 这样做会使物体中心指向当前位置
				scene.add(domino);
				dominos.push(domino);
			})
		}

		/**
		 * 给几何体创建位置点集
		 * @return {[type]} [description]
		 */
		function createPoints(){
			var points = [];
      var r = 27; // 最大半径
      var cX = 0; // 整体曲线的x偏移 （即在世界坐标系中的位置）, x轴
      var cY = 0; // 整体曲线的y偏移, z轴

      var pointSpace = 6; // 点间距
      var rChangeScope = 1440; // 半径变化范围，数值要与总圈数的角度有关

      var circleOffset = 0;

      for (var i = 0; i < 1000; i += pointSpace + circleOffset) {

          circleOffset = 4.5 * (i / 360); // 控制i的变化，可控制形状和生成点的数目
          var radiusChanged = (r / rChangeScope) * (rChangeScope - i); // 随i逐步变化

          var x = radiusChanged * Math.cos(i * (Math.PI / 180)) + cX;
          var z = radiusChanged * Math.sin(i * (Math.PI / 180)) + cY;
          var y = 0;
          points.push(new THREE.Vector3(x, y, z));

          // debug:
     			// var y = 5;
     			// var spGeom = new THREE.SphereGeometry(0.2);
					// var material = new THREE.MeshBasicMaterial({color: 0xFF0000, transparent: false});
					// var spMesh = new THREE.Mesh(spGeom, material);
					// spMesh.position.set(x, y, z);
					// scene.add(spMesh);
					
      }
      return points;
		}

		

		/**
		 * 创建有包围的地面
		 * @return {[type]} [description]
		 */
		function createGround(){
			// 参数：THREE材质对象，摩擦力系数，回弹系数
			var groundMaterial = Physijs.createMaterial(
				new THREE.MeshPhongMaterial( {
					map: THREE.ImageUtils.loadTexture("../assets/textures/general/wood-2.jpg")
				} ), materialContr.planeFriction, materialContr.planeRestitution);
			// 参数：几何对象，材质，质量
			ground = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 1, 60), groundMaterial, 0);
			// 左边框
			var borderLeft = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 3, 1), groundMaterial, 0);
			borderLeft.position.set(0, 1, -30);
			ground.add(borderLeft);
			// 右边框
			var borderRight = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 3, 1), groundMaterial, 0);
			borderRight.position.set(0, 1, 30);
			ground.add(borderRight);
			// 上边框
			var borderTop = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 3, 1), groundMaterial, 0);
			borderTop.position.set(30, 1, 0);
			borderTop.rotation.y = 0.5 * Math.PI;
			ground.add(borderTop);
			// 下边框
			var borderBottom = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 3, 1), groundMaterial, 0);
			borderBottom.position.set(-30, 1, 0);
			borderBottom.rotation.y = 0.5 * Math.PI;
			ground.add(borderBottom);

			scene.add(ground);
		}

		/**
		 * 创建高度图地形
		 * @param  {[type]} pn [噪音对象]
		 * @return {[type]}    [description]
		 */
		function createHightMapGround(pn){
			// 参数：THREE材质对象，摩擦力系数，回弹系数
			var groundMaterial = Physijs.createMaterial(
				new THREE.MeshPhongMaterial( {
					map: THREE.ImageUtils.loadTexture("../assets/grasslight-big.jpg")
				} ), materialContr.planeFriction, materialContr.planeRestitution);
			groundMaterial.map.wrapS = THREE.RepeatWrapping;
			groundMaterial.map.wrapT = THREE.RepeatWrapping;
			groundMaterial.map.repeat.set(3, 3);
			var groundGeometry = new THREE.PlaneGeometry(60, 60, 100, 100);
			for(var i=0, len = groundGeometry.vertices.length; i < len; i++){
				var vertex = groundGeometry.vertices[i];
				// 给顶点在x轴和y轴添加噪音处理
				var value = pn.noise(vertex.x / 10, vertex.y / 10, 0);
				vertex.z = value * 10;
			}
			// 重新计算面的法向量和顶点法向量
			groundGeometry.computeFaceNormals();
      groundGeometry.computeVertexNormals();
      // 后三个参数分别是：mass, xdiv(宽), ydiv(长)
			ground = new Physijs.HeightfieldMesh(groundGeometry, groundMaterial, 0, 100, 100);
			ground.rotation.x = -0.5 * Math.PI;
      // ground.rotation.y = 0.4;
      ground.receiveShadow = true;

      scene.add(ground);
		}

		/**
     * 初始化性能检测器
     * @return {[type]} [description]
     */
    function initStats(){
    	stats = new Stats();
    	stats.setMode(0); // 0: fps, 1: ms
    	stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0px';
      stats.domElement.style.top = '0px';

      document.getElementById("stats-output").appendChild(stats.domElement);
    }

		/**
		 * 窗口大小被重置
		 * @return {[type]} [description]
		 */
		function onResizeWindow(){
			// 相机宽高比
			camera.aspect = window.innerWidth/window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		window.onload = init;

		window.addEventListener('resize', onResizeWindow, false);

	</script>
</body>
</html>