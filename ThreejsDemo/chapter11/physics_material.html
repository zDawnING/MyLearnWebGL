<!DOCTYPE html>
<html>
<meta charset="utf-8">
<head>
	<title>基础场景设置</title>
</head>
<style type="text/css">
	body{
		/*设置全屏*/
		margin: 0;
		overflow: hidden;
	}
</style>
<body>

	<div id="stats-output"></div>
	<div id="webgl-output"></div>
	
	<script type="text/javascript" src="../lib/three.js"></script>
	<script type="text/javascript" src="../lib/stats.js"></script>
	<!-- 相机控制 -->
	<script type="text/javascript" src="../lib/controls/OrbitControls.js"></script>
	<!-- ammo.js的包装器，属于简单应用引擎的threejs插件 -->
	<script type="text/javascript" src="../lib/physi.js"></script>
	<script type="text/javascript" src="../lib/dat.gui.js"></script>

	<script type="text/javascript">
		// Physijs 只是ammo.js的一个包装器，ammo.js是基于bullet physics物理引擎直接编译过来的js文件
		// 引入H5的web workers(网页线程)，使引擎可以在一个单独的线程里执行cpu密集的任务，从而不影响渲染
		Physijs.scripts.worker = '../lib/physijs_worker.js';
    Physijs.scripts.ammo = '../lib/ammo.js';

	</script>

	<script type="text/javascript">
		
		// 定义全局变量
		var camera; // 相机
		var scene; // 场景对象
		var renderer; // 渲染器
		// 辅助组件
		var stats; // 检测动画运行帧频
		var gui; // 控制界面变量的组件

		// 场景对象(放置全局方便特殊处理)
		var ground, dominos = [];
		// 场景相关控制变量
		var step = 0; // 记录弹跳的增量
    var controls;
    var clock;
    var orbitControls;

    /**
     * 初始化控制器
     * @return {[type]} [description]
     */
    function initControler(){
    	controls = new function () {
    		this.gravityX = 0;
        this.gravityY = -50;
        this.gravityZ = 0;
        this.start = function(){
        	pushFirstDomino();
        }
	    };

    	gui = new dat.GUI();
    	gui.add(controls, 'start');
    	var folder = gui.addFolder("GravityControls");
    	folder.add(controls, 'gravityX', -100, 100).onChange(setSceneGravity);
    	folder.add(controls, 'gravityY', -100, 100).onChange(setSceneGravity);
    	folder.add(controls, 'gravityZ', -100, 100).onChange(setSceneGravity);
    }

    /**
     * 渲染
     * @return {[type]} [description]
     */
    function render(){
    	var delta = clock.getDelta();
    	stats.update(); // 即时更新FPS
    	
    	orbitControls.update(delta);

    	scene.simulate(undefined, 1);

    	// 使用帧动画函数
    	requestAnimationFrame(render);
    	renderer.render( scene, camera );
    }

		/**
		 * 初始化所有配置
		 * @return {[type]} [description]
		 */
		function init(){
			// 初始化组件
			var stats = initStats();

			// 创建场景, 这里的场景创建要使用Physijs的scene对象
			scene = new Physijs.Scene; // 创建了一个已经应用了物理的场景
			scene.setGravity(new THREE.Vector3( 0, -10, 0 )); // 设置了y轴方向的重力，创建的对象会竖直下落

			// 创建相机
			camera = new THREE.PerspectiveCamera( 45, window.innerWidth/window.innerHeight, 0.1, 1000 );
			camera.position.x = -30;
			camera.position.y = 30;
			camera.position.z = 30;
			camera.lookAt(scene.position); // 视线指向场景中心
			// 创建渲染器
			renderer = new THREE.WebGLRenderer();

			// 擦除背景色
			renderer.setClearColor(new THREE.Color( 0xEEEEEE, 1.0 ));
			renderer.setSize(window.innerWidth, window.innerHeight); // 设置视口大小
			renderer.shadowMapEnabled = true; // 启用阴影贴图

			// 配置控制器
			initControler();

			// 展示辅助观察的世界坐标系
      var axes = new THREE.AxisHelper(20);
      scene.add(axes);

      clock = new THREE.Clock();

      orbitControls = new THREE.OrbitControls(camera);

      createGround();

      var points = createPoints();

      setSceneGravity();

      loadDominoObjects(points);

			// 添加环境光
			var ambientLight = new THREE.AmbientLight( 0x0C0C0C );
			scene.add(ambientLight);

			// 添加点光源,作为产生阴影的光源
			var spotLight = new THREE.SpotLight(0xFFFFFF);
			spotLight.position.set(-40, 60, -10);
			spotLight.castShadow = true;
			scene.add(spotLight);

			// 把渲染内容输出至dom中
			document.getElementById("webgl-output").appendChild(renderer.domElement);

			
			// 开始渲染
			render();
		}

		

		/**
		 * 给场景设置重力
		 */
		function setSceneGravity(){
			scene.setGravity(new THREE.Vector3(controls.gravityX, controls.gravityY, controls.gravityZ));
		}

		/**
		 * 加载多米诺骨牌
		 * @return {[type]} [description]
		 */
		function loadDominoObjects(points){
			points.forEach(function(point){
				var geometry = new THREE.BoxGeometry(0.6, 6, 2);
				var material = new Physijs.createMaterial(new THREE.MeshPhongMaterial({
					color: Math.random() * 0xFFFFFF,
					opacity: 0.9,
					transparent: true
				})); // 这里不设置摩擦力和回弹
				var domino = new Physijs.BoxMesh(geometry, material); // 这里也不设置质量
				domino.position.copy(point);
				domino.position.y = 3.5; // 确保骨牌底部贴紧地面
				domino.lookAt(new THREE.Vector3(0, 3.5, 0)); // 这样做会使物体中心指向当前位置
				scene.add(domino);
				dominos.push(domino);
			})
		}

		/**
		 * 给几何体创建位置点集
		 * @return {[type]} [description]
		 */
		function createPoints(){
			var points = [];
      var r = 27; // 最大半径
      var cX = 0; // 整体曲线的x偏移 （即在世界坐标系中的位置）, x轴
      var cY = 0; // 整体曲线的y偏移, z轴

      var pointSpace = 6; // 点间距
      var rChangeScope = 1440; // 半径变化范围，数值要与总圈数的角度有关

      var circleOffset = 0;

      for (var i = 0; i < 1000; i += pointSpace + circleOffset) {

          circleOffset = 4.5 * (i / 360); // 控制i的变化，可控制形状和生成点的数目
          var radiusChanged = (r / rChangeScope) * (rChangeScope - i); // 随i逐步变化

          var x = radiusChanged * Math.cos(i * (Math.PI / 180)) + cX;
          var z = radiusChanged * Math.sin(i * (Math.PI / 180)) + cY;
          var y = 0;
          points.push(new THREE.Vector3(x, y, z));

          // debug:
     			// var y = 5;
     			// var spGeom = new THREE.SphereGeometry(0.2);
					// var material = new THREE.MeshBasicMaterial({color: 0xFF0000, transparent: false});
					// var spMesh = new THREE.Mesh(spGeom, material);
					// spMesh.position.set(x, y, z);
					// scene.add(spMesh);
					
      }
      return points;
		}

		/**
		 * 创建有包围的地面
		 * @return {[type]} [description]
		 */
		function createGround(){
			// 参数：THREE材质对象，摩擦力系数，回弹系数
			var groundMaterial = Physijs.createMaterial(
				new THREE.MeshPhongMaterial( {
					map: THREE.ImageUtils.loadTexture("../assets/textures/general/wood-2.jpg")
				} ), 0.9, 0.3);
			// 参数：几何对象，材质，质量
			ground = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 1, 60), groundMaterial, 0);
			// 左边框
			var borderLeft = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 3, 1), groundMaterial, 0);
			borderLeft.position.set(0, 1, -30);
			ground.add(borderLeft);
			// 右边框
			var borderRight = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 3, 1), groundMaterial, 0);
			borderRight.position.set(0, 1, 30);
			ground.add(borderRight);
			// 上边框
			var borderTop = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 3, 1), groundMaterial, 0);
			borderTop.position.set(30, 1, 0);
			borderTop.rotation.y = 0.5 * Math.PI;
			ground.add(borderTop);
			// 下边框
			var borderBottom = new Physijs.BoxMesh(new THREE.BoxGeometry(60, 3, 1), groundMaterial, 0);
			borderBottom.position.set(-30, 1, 0);
			borderBottom.rotation.y = 0.5 * Math.PI;
			ground.add(borderBottom);

			scene.add(ground);
		}

		/**
     * 初始化性能检测器
     * @return {[type]} [description]
     */
    function initStats(){
    	stats = new Stats();
    	stats.setMode(0); // 0: fps, 1: ms
    	stats.domElement.style.position = 'absolute';
      stats.domElement.style.left = '0px';
      stats.domElement.style.top = '0px';

      document.getElementById("stats-output").appendChild(stats.domElement);
    }

		/**
		 * 窗口大小被重置
		 * @return {[type]} [description]
		 */
		function onResizeWindow(){
			// 相机宽高比
			camera.aspect = window.innerWidth/window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}

		window.onload = init;

		window.addEventListener('resize', onResizeWindow, false);

	</script>
</body>
</html>